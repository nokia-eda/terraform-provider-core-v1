// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_auth_providers

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func AuthProvidersDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"auth_providers": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auth": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"bind_credential": schema.StringAttribute{
									Computed:            true,
									Description:         "Credentials to use when binding to an LDAP provider",
									MarkdownDescription: "Credentials to use when binding to an LDAP provider",
								},
								"bind_dn": schema.StringAttribute{
									Computed:            true,
									Description:         "DN to use when binding to an LDAP provider",
									MarkdownDescription: "DN to use when binding to an LDAP provider",
								},
							},
							CustomType: AuthType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "If present, bind to LDAP server with the given credentials.  Otherwise do not bind.",
							MarkdownDescription: "If present, bind to LDAP server with the given credentials.  Otherwise do not bind.",
						},
						"enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If true, checking/syncing this LDAP provider is enabled.",
							MarkdownDescription: "If true, checking/syncing this LDAP provider is enabled.",
						},
						"group_support": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"filter": schema.StringAttribute{
									Computed:            true,
									Description:         "Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using.",
									MarkdownDescription: "Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using.",
								},
								"group_ldapdn": schema.StringAttribute{
									Computed:            true,
									Description:         "The LDAP DN where groups are found.",
									MarkdownDescription: "The LDAP DN where groups are found.",
								},
								"member_attribute": schema.StringAttribute{
									Computed:            true,
									Description:         "The group attribute for a members.  Usually \"member\" or \"memberUid\".",
									MarkdownDescription: "The group attribute for a members.  Usually \"member\" or \"memberUid\".",
								},
								"member_of_attribute": schema.StringAttribute{
									Computed:            true,
									Description:         "If retrievalStrategy is \"memberOf\", this is the LDAP user attribute for group memberships.",
									MarkdownDescription: "If retrievalStrategy is \"memberOf\", this is the LDAP user attribute for group memberships.",
								},
								"membership_attribute_type": schema.StringAttribute{
									Computed:            true,
									Description:         "How users are identified in a group member entry: either DN or UID.",
									MarkdownDescription: "How users are identified in a group member entry: either DN or UID.",
								},
								"membership_user_attribute": schema.StringAttribute{
									Computed:            true,
									Description:         "Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value.",
									MarkdownDescription: "Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value.",
								},
								"name_ldapattribute": schema.StringAttribute{
									Computed:            true,
									Description:         "The LDAP group name attribute",
									MarkdownDescription: "The LDAP group name attribute",
								},
								"object_classes": schema.StringAttribute{
									Computed:            true,
									Description:         "The LDAP object class or classes used for groups. If more than one, they must be comma-separated.",
									MarkdownDescription: "The LDAP object class or classes used for groups. If more than one, they must be comma-separated.",
								},
								"retrieval_strategy": schema.StringAttribute{
									Computed:            true,
									Description:         "The strategy for retrieving groups.  Should be \"member\" to get group membership from the group, or \"memberOf\" to get group membership from the user.",
									MarkdownDescription: "The strategy for retrieving groups.  Should be \"member\" to get group membership from the group, or \"memberOf\" to get group membership from the user.",
								},
							},
							CustomType: GroupSupportType{
								ObjectType: types.ObjectType{
									AttrTypes: GroupSupportValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.",
							MarkdownDescription: "Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.",
						},
						"id_attribute": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP.",
							MarkdownDescription: "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP.",
						},
						"import": schema.BoolAttribute{
							Computed:            true,
							Description:         "If true, the LDAP information will be imported into the EDA (Keycloak) database.",
							MarkdownDescription: "If true, the LDAP information will be imported into the EDA (Keycloak) database.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name to give to the LDAP provider; must be unique.",
							MarkdownDescription: "The name to give to the LDAP provider; must be unique.",
						},
						"pagination": schema.BoolAttribute{
							Computed:            true,
							Description:         "Set to true if the LDAP server supports pagination.",
							MarkdownDescription: "Set to true if the LDAP server supports pagination.",
						},
						"periodic_sync": schema.BoolAttribute{
							Computed:            true,
							Description:         "If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur.",
							MarkdownDescription: "If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur.",
						},
						"periodic_sync_secs": schema.Int64Attribute{
							Computed:            true,
							Description:         "If periodic sync is enabled, this is the period in seconds that synchronization will occur.",
							MarkdownDescription: "If periodic sync is enabled, this is the period in seconds that synchronization will occur.",
						},
						"rdn_ldapattribute": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required.",
							MarkdownDescription: "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required.",
						},
						"read_only": schema.BoolAttribute{
							Computed:            true,
							Description:         "If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.",
							MarkdownDescription: "If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.",
						},
						"scope": schema.StringAttribute{
							Computed:            true,
							Description:         "Must be \"One Level\" or \"Subtree\".  If \"One Level\", the search applies only for users in the DNs specified by User DNs. If \"Subtree\", the search applies to the whole subtree.",
							MarkdownDescription: "Must be \"One Level\" or \"Subtree\".  If \"One Level\", the search applies only for users in the DNs specified by User DNs. If \"Subtree\", the search applies to the whole subtree.",
						},
						"timeout": schema.Int64Attribute{
							Computed:            true,
							Description:         "LDAP connection timeout in milliseconds",
							MarkdownDescription: "LDAP connection timeout in milliseconds",
						},
						"tls": schema.BoolAttribute{
							Computed:            true,
							Description:         "If true, encrypts the connection to LDAP using STARTTLS",
							MarkdownDescription: "If true, encrypts the connection to LDAP using STARTTLS",
						},
						"type": schema.StringAttribute{
							Computed:            true,
							Description:         "The type of provider.  Currently only \"ldap\" is supported.",
							MarkdownDescription: "The type of provider.  Currently only \"ldap\" is supported.",
						},
						"url": schema.StringAttribute{
							Computed:            true,
							Description:         "Connection URL to your LDAP server",
							MarkdownDescription: "Connection URL to your LDAP server",
						},
						"user_dn": schema.StringAttribute{
							Computed:            true,
							Description:         "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users.",
							MarkdownDescription: "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users.",
						},
						"user_object_classes": schema.StringAttribute{
							Computed:            true,
							Description:         "All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson).",
							MarkdownDescription: "All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson).",
						},
						"user_search_filter": schema.StringAttribute{
							Computed:            true,
							Description:         "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
							MarkdownDescription: "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
						},
						"username_attribute": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'.",
							MarkdownDescription: "Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'.",
						},
						"uuid": schema.StringAttribute{
							Computed:            true,
							Description:         "The unique identifier given to the entry when it is created.",
							MarkdownDescription: "The unique identifier given to the entry when it is created.",
						},
						"vendor": schema.StringAttribute{
							Computed:            true,
							Description:         "LDAP vendor (provider).",
							MarkdownDescription: "LDAP vendor (provider).",
						},
					},
					CustomType: AuthProvidersType{
						ObjectType: types.ObjectType{
							AttrTypes: AuthProvidersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The result will be limited to providers whose name is this parameter.",
				MarkdownDescription: "The result will be limited to providers whose name is this parameter.",
			},
		},
	}
}

type AuthProvidersModel struct {
	AuthProviders types.Set    `tfsdk:"auth_providers"`
	Name          types.String `tfsdk:"name"`
}

var _ basetypes.ObjectTypable = AuthProvidersType{}

type AuthProvidersType struct {
	basetypes.ObjectType
}

func (t AuthProvidersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthProvidersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthProvidersType) String() string {
	return "AuthProvidersType"
}

func (t AuthProvidersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return nil, diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupSupportAttribute, ok := attributes["group_support"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_support is missing from object`)

		return nil, diags
	}

	groupSupportVal, ok := groupSupportAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_support expected to be basetypes.ObjectValue, was: %T`, groupSupportAttribute))
	}

	idAttributeAttribute, ok := attributes["id_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_attribute is missing from object`)

		return nil, diags
	}

	idAttributeVal, ok := idAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_attribute expected to be basetypes.StringValue, was: %T`, idAttributeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return nil, diags
	}

	importVal, ok := importAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.BoolValue, was: %T`, importAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	paginationAttribute, ok := attributes["pagination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pagination is missing from object`)

		return nil, diags
	}

	paginationVal, ok := paginationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pagination expected to be basetypes.BoolValue, was: %T`, paginationAttribute))
	}

	periodicSyncAttribute, ok := attributes["periodic_sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`periodic_sync is missing from object`)

		return nil, diags
	}

	periodicSyncVal, ok := periodicSyncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`periodic_sync expected to be basetypes.BoolValue, was: %T`, periodicSyncAttribute))
	}

	periodicSyncSecsAttribute, ok := attributes["periodic_sync_secs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`periodic_sync_secs is missing from object`)

		return nil, diags
	}

	periodicSyncSecsVal, ok := periodicSyncSecsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`periodic_sync_secs expected to be basetypes.Int64Value, was: %T`, periodicSyncSecsAttribute))
	}

	rdnLdapattributeAttribute, ok := attributes["rdn_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rdn_ldapattribute is missing from object`)

		return nil, diags
	}

	rdnLdapattributeVal, ok := rdnLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rdn_ldapattribute expected to be basetypes.StringValue, was: %T`, rdnLdapattributeAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return nil, diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return nil, diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.BoolValue, was: %T`, tlsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userDnAttribute, ok := attributes["user_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_dn is missing from object`)

		return nil, diags
	}

	userDnVal, ok := userDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_dn expected to be basetypes.StringValue, was: %T`, userDnAttribute))
	}

	userObjectClassesAttribute, ok := attributes["user_object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_object_classes is missing from object`)

		return nil, diags
	}

	userObjectClassesVal, ok := userObjectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_object_classes expected to be basetypes.StringValue, was: %T`, userObjectClassesAttribute))
	}

	userSearchFilterAttribute, ok := attributes["user_search_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_search_filter is missing from object`)

		return nil, diags
	}

	userSearchFilterVal, ok := userSearchFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_search_filter expected to be basetypes.StringValue, was: %T`, userSearchFilterAttribute))
	}

	usernameAttributeAttribute, ok := attributes["username_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_attribute is missing from object`)

		return nil, diags
	}

	usernameAttributeVal, ok := usernameAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_attribute expected to be basetypes.StringValue, was: %T`, usernameAttributeAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vendorAttribute, ok := attributes["vendor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor is missing from object`)

		return nil, diags
	}

	vendorVal, ok := vendorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor expected to be basetypes.StringValue, was: %T`, vendorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthProvidersValue{
		Auth:              authVal,
		Enabled:           enabledVal,
		GroupSupport:      groupSupportVal,
		IdAttribute:       idAttributeVal,
		Import:            importVal,
		Name:              nameVal,
		Pagination:        paginationVal,
		PeriodicSync:      periodicSyncVal,
		PeriodicSyncSecs:  periodicSyncSecsVal,
		RdnLdapattribute:  rdnLdapattributeVal,
		ReadOnly:          readOnlyVal,
		Scope:             scopeVal,
		Timeout:           timeoutVal,
		Tls:               tlsVal,
		AuthProvidersType: typeVal,
		Url:               urlVal,
		UserDn:            userDnVal,
		UserObjectClasses: userObjectClassesVal,
		UserSearchFilter:  userSearchFilterVal,
		UsernameAttribute: usernameAttributeVal,
		Uuid:              uuidVal,
		Vendor:            vendorVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthProvidersValueNull() AuthProvidersValue {
	return AuthProvidersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthProvidersValueUnknown() AuthProvidersValue {
	return AuthProvidersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthProvidersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthProvidersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthProvidersValue Attribute Value",
				"While creating a AuthProvidersValue value, a missing attribute value was detected. "+
					"A AuthProvidersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthProvidersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthProvidersValue Attribute Type",
				"While creating a AuthProvidersValue value, an invalid attribute value was detected. "+
					"A AuthProvidersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthProvidersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthProvidersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthProvidersValue Attribute Value",
				"While creating a AuthProvidersValue value, an extra attribute value was detected. "+
					"A AuthProvidersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthProvidersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthProvidersValueUnknown(), diags
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupSupportAttribute, ok := attributes["group_support"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_support is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	groupSupportVal, ok := groupSupportAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_support expected to be basetypes.ObjectValue, was: %T`, groupSupportAttribute))
	}

	idAttributeAttribute, ok := attributes["id_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_attribute is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	idAttributeVal, ok := idAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_attribute expected to be basetypes.StringValue, was: %T`, idAttributeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	importVal, ok := importAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.BoolValue, was: %T`, importAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	paginationAttribute, ok := attributes["pagination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pagination is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	paginationVal, ok := paginationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pagination expected to be basetypes.BoolValue, was: %T`, paginationAttribute))
	}

	periodicSyncAttribute, ok := attributes["periodic_sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`periodic_sync is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	periodicSyncVal, ok := periodicSyncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`periodic_sync expected to be basetypes.BoolValue, was: %T`, periodicSyncAttribute))
	}

	periodicSyncSecsAttribute, ok := attributes["periodic_sync_secs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`periodic_sync_secs is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	periodicSyncSecsVal, ok := periodicSyncSecsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`periodic_sync_secs expected to be basetypes.Int64Value, was: %T`, periodicSyncSecsAttribute))
	}

	rdnLdapattributeAttribute, ok := attributes["rdn_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rdn_ldapattribute is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	rdnLdapattributeVal, ok := rdnLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rdn_ldapattribute expected to be basetypes.StringValue, was: %T`, rdnLdapattributeAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	tlsAttribute, ok := attributes["tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	tlsVal, ok := tlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls expected to be basetypes.BoolValue, was: %T`, tlsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userDnAttribute, ok := attributes["user_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_dn is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	userDnVal, ok := userDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_dn expected to be basetypes.StringValue, was: %T`, userDnAttribute))
	}

	userObjectClassesAttribute, ok := attributes["user_object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_object_classes is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	userObjectClassesVal, ok := userObjectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_object_classes expected to be basetypes.StringValue, was: %T`, userObjectClassesAttribute))
	}

	userSearchFilterAttribute, ok := attributes["user_search_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_search_filter is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	userSearchFilterVal, ok := userSearchFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_search_filter expected to be basetypes.StringValue, was: %T`, userSearchFilterAttribute))
	}

	usernameAttributeAttribute, ok := attributes["username_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_attribute is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	usernameAttributeVal, ok := usernameAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_attribute expected to be basetypes.StringValue, was: %T`, usernameAttributeAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vendorAttribute, ok := attributes["vendor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor is missing from object`)

		return NewAuthProvidersValueUnknown(), diags
	}

	vendorVal, ok := vendorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor expected to be basetypes.StringValue, was: %T`, vendorAttribute))
	}

	if diags.HasError() {
		return NewAuthProvidersValueUnknown(), diags
	}

	return AuthProvidersValue{
		Auth:              authVal,
		Enabled:           enabledVal,
		GroupSupport:      groupSupportVal,
		IdAttribute:       idAttributeVal,
		Import:            importVal,
		Name:              nameVal,
		Pagination:        paginationVal,
		PeriodicSync:      periodicSyncVal,
		PeriodicSyncSecs:  periodicSyncSecsVal,
		RdnLdapattribute:  rdnLdapattributeVal,
		ReadOnly:          readOnlyVal,
		Scope:             scopeVal,
		Timeout:           timeoutVal,
		Tls:               tlsVal,
		AuthProvidersType: typeVal,
		Url:               urlVal,
		UserDn:            userDnVal,
		UserObjectClasses: userObjectClassesVal,
		UserSearchFilter:  userSearchFilterVal,
		UsernameAttribute: usernameAttributeVal,
		Uuid:              uuidVal,
		Vendor:            vendorVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAuthProvidersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthProvidersValue {
	object, diags := NewAuthProvidersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthProvidersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthProvidersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthProvidersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthProvidersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthProvidersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthProvidersValueMust(AuthProvidersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthProvidersType) ValueType(ctx context.Context) attr.Value {
	return AuthProvidersValue{}
}

var _ basetypes.ObjectValuable = AuthProvidersValue{}

type AuthProvidersValue struct {
	Auth              basetypes.ObjectValue `tfsdk:"auth"`
	Enabled           basetypes.BoolValue   `tfsdk:"enabled"`
	GroupSupport      basetypes.ObjectValue `tfsdk:"group_support"`
	IdAttribute       basetypes.StringValue `tfsdk:"id_attribute"`
	Import            basetypes.BoolValue   `tfsdk:"import"`
	Name              basetypes.StringValue `tfsdk:"name"`
	Pagination        basetypes.BoolValue   `tfsdk:"pagination"`
	PeriodicSync      basetypes.BoolValue   `tfsdk:"periodic_sync"`
	PeriodicSyncSecs  basetypes.Int64Value  `tfsdk:"periodic_sync_secs"`
	RdnLdapattribute  basetypes.StringValue `tfsdk:"rdn_ldapattribute"`
	ReadOnly          basetypes.BoolValue   `tfsdk:"read_only"`
	Scope             basetypes.StringValue `tfsdk:"scope"`
	Timeout           basetypes.Int64Value  `tfsdk:"timeout"`
	Tls               basetypes.BoolValue   `tfsdk:"tls"`
	AuthProvidersType basetypes.StringValue `tfsdk:"type"`
	Url               basetypes.StringValue `tfsdk:"url"`
	UserDn            basetypes.StringValue `tfsdk:"user_dn"`
	UserObjectClasses basetypes.StringValue `tfsdk:"user_object_classes"`
	UserSearchFilter  basetypes.StringValue `tfsdk:"user_search_filter"`
	UsernameAttribute basetypes.StringValue `tfsdk:"username_attribute"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	Vendor            basetypes.StringValue `tfsdk:"vendor"`
	state             attr.ValueState
}

func (v AuthProvidersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["auth"] = basetypes.ObjectType{
		AttrTypes: AuthValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["group_support"] = basetypes.ObjectType{
		AttrTypes: GroupSupportValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pagination"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["periodic_sync"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["periodic_sync_secs"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rdn_ldapattribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tls"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_dn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_object_classes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_search_filter"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.Auth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.GroupSupport.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_support"] = val

		val, err = v.IdAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id_attribute"] = val

		val, err = v.Import.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Pagination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pagination"] = val

		val, err = v.PeriodicSync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["periodic_sync"] = val

		val, err = v.PeriodicSyncSecs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["periodic_sync_secs"] = val

		val, err = v.RdnLdapattribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rdn_ldapattribute"] = val

		val, err = v.ReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_only"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		val, err = v.Tls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tls"] = val

		val, err = v.AuthProvidersType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.UserDn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_dn"] = val

		val, err = v.UserObjectClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_object_classes"] = val

		val, err = v.UserSearchFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_search_filter"] = val

		val, err = v.UsernameAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username_attribute"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		val, err = v.Vendor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthProvidersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthProvidersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthProvidersValue) String() string {
	return "AuthProvidersValue"
}

func (v AuthProvidersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var auth basetypes.ObjectValue

	if v.Auth.IsNull() {
		auth = types.ObjectNull(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if v.Auth.IsUnknown() {
		auth = types.ObjectUnknown(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Auth.IsNull() && !v.Auth.IsUnknown() {
		auth = types.ObjectValueMust(
			AuthValue{}.AttributeTypes(ctx),
			v.Auth.Attributes(),
		)
	}

	var groupSupport basetypes.ObjectValue

	if v.GroupSupport.IsNull() {
		groupSupport = types.ObjectNull(
			GroupSupportValue{}.AttributeTypes(ctx),
		)
	}

	if v.GroupSupport.IsUnknown() {
		groupSupport = types.ObjectUnknown(
			GroupSupportValue{}.AttributeTypes(ctx),
		)
	}

	if !v.GroupSupport.IsNull() && !v.GroupSupport.IsUnknown() {
		groupSupport = types.ObjectValueMust(
			GroupSupportValue{}.AttributeTypes(ctx),
			v.GroupSupport.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"group_support": basetypes.ObjectType{
			AttrTypes: GroupSupportValue{}.AttributeTypes(ctx),
		},
		"id_attribute":        basetypes.StringType{},
		"import":              basetypes.BoolType{},
		"name":                basetypes.StringType{},
		"pagination":          basetypes.BoolType{},
		"periodic_sync":       basetypes.BoolType{},
		"periodic_sync_secs":  basetypes.Int64Type{},
		"rdn_ldapattribute":   basetypes.StringType{},
		"read_only":           basetypes.BoolType{},
		"scope":               basetypes.StringType{},
		"timeout":             basetypes.Int64Type{},
		"tls":                 basetypes.BoolType{},
		"type":                basetypes.StringType{},
		"url":                 basetypes.StringType{},
		"user_dn":             basetypes.StringType{},
		"user_object_classes": basetypes.StringType{},
		"user_search_filter":  basetypes.StringType{},
		"username_attribute":  basetypes.StringType{},
		"uuid":                basetypes.StringType{},
		"vendor":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth":                auth,
			"enabled":             v.Enabled,
			"group_support":       groupSupport,
			"id_attribute":        v.IdAttribute,
			"import":              v.Import,
			"name":                v.Name,
			"pagination":          v.Pagination,
			"periodic_sync":       v.PeriodicSync,
			"periodic_sync_secs":  v.PeriodicSyncSecs,
			"rdn_ldapattribute":   v.RdnLdapattribute,
			"read_only":           v.ReadOnly,
			"scope":               v.Scope,
			"timeout":             v.Timeout,
			"tls":                 v.Tls,
			"type":                v.AuthProvidersType,
			"url":                 v.Url,
			"user_dn":             v.UserDn,
			"user_object_classes": v.UserObjectClasses,
			"user_search_filter":  v.UserSearchFilter,
			"username_attribute":  v.UsernameAttribute,
			"uuid":                v.Uuid,
			"vendor":              v.Vendor,
		})

	return objVal, diags
}

func (v AuthProvidersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthProvidersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Auth.Equal(other.Auth) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.GroupSupport.Equal(other.GroupSupport) {
		return false
	}

	if !v.IdAttribute.Equal(other.IdAttribute) {
		return false
	}

	if !v.Import.Equal(other.Import) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Pagination.Equal(other.Pagination) {
		return false
	}

	if !v.PeriodicSync.Equal(other.PeriodicSync) {
		return false
	}

	if !v.PeriodicSyncSecs.Equal(other.PeriodicSyncSecs) {
		return false
	}

	if !v.RdnLdapattribute.Equal(other.RdnLdapattribute) {
		return false
	}

	if !v.ReadOnly.Equal(other.ReadOnly) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	if !v.Tls.Equal(other.Tls) {
		return false
	}

	if !v.AuthProvidersType.Equal(other.AuthProvidersType) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.UserDn.Equal(other.UserDn) {
		return false
	}

	if !v.UserObjectClasses.Equal(other.UserObjectClasses) {
		return false
	}

	if !v.UserSearchFilter.Equal(other.UserSearchFilter) {
		return false
	}

	if !v.UsernameAttribute.Equal(other.UsernameAttribute) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	if !v.Vendor.Equal(other.Vendor) {
		return false
	}

	return true
}

func (v AuthProvidersValue) Type(ctx context.Context) attr.Type {
	return AuthProvidersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthProvidersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"group_support": basetypes.ObjectType{
			AttrTypes: GroupSupportValue{}.AttributeTypes(ctx),
		},
		"id_attribute":        basetypes.StringType{},
		"import":              basetypes.BoolType{},
		"name":                basetypes.StringType{},
		"pagination":          basetypes.BoolType{},
		"periodic_sync":       basetypes.BoolType{},
		"periodic_sync_secs":  basetypes.Int64Type{},
		"rdn_ldapattribute":   basetypes.StringType{},
		"read_only":           basetypes.BoolType{},
		"scope":               basetypes.StringType{},
		"timeout":             basetypes.Int64Type{},
		"tls":                 basetypes.BoolType{},
		"type":                basetypes.StringType{},
		"url":                 basetypes.StringType{},
		"user_dn":             basetypes.StringType{},
		"user_object_classes": basetypes.StringType{},
		"user_search_filter":  basetypes.StringType{},
		"username_attribute":  basetypes.StringType{},
		"uuid":                basetypes.StringType{},
		"vendor":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthType{}

type AuthType struct {
	basetypes.ObjectType
}

func (t AuthType) Equal(o attr.Type) bool {
	other, ok := o.(AuthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthType) String() string {
	return "AuthType"
}

func (t AuthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bindCredentialAttribute, ok := attributes["bind_credential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_credential is missing from object`)

		return nil, diags
	}

	bindCredentialVal, ok := bindCredentialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_credential expected to be basetypes.StringValue, was: %T`, bindCredentialAttribute))
	}

	bindDnAttribute, ok := attributes["bind_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_dn is missing from object`)

		return nil, diags
	}

	bindDnVal, ok := bindDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_dn expected to be basetypes.StringValue, was: %T`, bindDnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthValue{
		BindCredential: bindCredentialVal,
		BindDn:         bindDnVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthValueNull() AuthValue {
	return AuthValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthValueUnknown() AuthValue {
	return AuthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthValue Attribute Value",
				"While creating a AuthValue value, a missing attribute value was detected. "+
					"A AuthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthValue Attribute Type",
				"While creating a AuthValue value, an invalid attribute value was detected. "+
					"A AuthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthValue Attribute Value",
				"While creating a AuthValue value, an extra attribute value was detected. "+
					"A AuthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	bindCredentialAttribute, ok := attributes["bind_credential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_credential is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	bindCredentialVal, ok := bindCredentialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_credential expected to be basetypes.StringValue, was: %T`, bindCredentialAttribute))
	}

	bindDnAttribute, ok := attributes["bind_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_dn is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	bindDnVal, ok := bindDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_dn expected to be basetypes.StringValue, was: %T`, bindDnAttribute))
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	return AuthValue{
		BindCredential: bindCredentialVal,
		BindDn:         bindDnVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthValue {
	object, diags := NewAuthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthValueMust(AuthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthType) ValueType(ctx context.Context) attr.Value {
	return AuthValue{}
}

var _ basetypes.ObjectValuable = AuthValue{}

type AuthValue struct {
	BindCredential basetypes.StringValue `tfsdk:"bind_credential"`
	BindDn         basetypes.StringValue `tfsdk:"bind_dn"`
	state          attr.ValueState
}

func (v AuthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bind_credential"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bind_dn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.BindCredential.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bind_credential"] = val

		val, err = v.BindDn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bind_dn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthValue) String() string {
	return "AuthValue"
}

func (v AuthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bind_credential": basetypes.StringType{},
		"bind_dn":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bind_credential": v.BindCredential,
			"bind_dn":         v.BindDn,
		})

	return objVal, diags
}

func (v AuthValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BindCredential.Equal(other.BindCredential) {
		return false
	}

	if !v.BindDn.Equal(other.BindDn) {
		return false
	}

	return true
}

func (v AuthValue) Type(ctx context.Context) attr.Type {
	return AuthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bind_credential": basetypes.StringType{},
		"bind_dn":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GroupSupportType{}

type GroupSupportType struct {
	basetypes.ObjectType
}

func (t GroupSupportType) Equal(o attr.Type) bool {
	other, ok := o.(GroupSupportType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupSupportType) String() string {
	return "GroupSupportType"
}

func (t GroupSupportType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return nil, diags
	}

	filterVal, ok := filterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.StringValue, was: %T`, filterAttribute))
	}

	groupLdapdnAttribute, ok := attributes["group_ldapdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_ldapdn is missing from object`)

		return nil, diags
	}

	groupLdapdnVal, ok := groupLdapdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_ldapdn expected to be basetypes.StringValue, was: %T`, groupLdapdnAttribute))
	}

	memberAttributeAttribute, ok := attributes["member_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_attribute is missing from object`)

		return nil, diags
	}

	memberAttributeVal, ok := memberAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_attribute expected to be basetypes.StringValue, was: %T`, memberAttributeAttribute))
	}

	memberOfAttributeAttribute, ok := attributes["member_of_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_of_attribute is missing from object`)

		return nil, diags
	}

	memberOfAttributeVal, ok := memberOfAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_of_attribute expected to be basetypes.StringValue, was: %T`, memberOfAttributeAttribute))
	}

	membershipAttributeTypeAttribute, ok := attributes["membership_attribute_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_attribute_type is missing from object`)

		return nil, diags
	}

	membershipAttributeTypeVal, ok := membershipAttributeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_attribute_type expected to be basetypes.StringValue, was: %T`, membershipAttributeTypeAttribute))
	}

	membershipUserAttributeAttribute, ok := attributes["membership_user_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_user_attribute is missing from object`)

		return nil, diags
	}

	membershipUserAttributeVal, ok := membershipUserAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_user_attribute expected to be basetypes.StringValue, was: %T`, membershipUserAttributeAttribute))
	}

	nameLdapattributeAttribute, ok := attributes["name_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_ldapattribute is missing from object`)

		return nil, diags
	}

	nameLdapattributeVal, ok := nameLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_ldapattribute expected to be basetypes.StringValue, was: %T`, nameLdapattributeAttribute))
	}

	objectClassesAttribute, ok := attributes["object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_classes is missing from object`)

		return nil, diags
	}

	objectClassesVal, ok := objectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_classes expected to be basetypes.StringValue, was: %T`, objectClassesAttribute))
	}

	retrievalStrategyAttribute, ok := attributes["retrieval_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retrieval_strategy is missing from object`)

		return nil, diags
	}

	retrievalStrategyVal, ok := retrievalStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retrieval_strategy expected to be basetypes.StringValue, was: %T`, retrievalStrategyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupSupportValue{
		Filter:                  filterVal,
		GroupLdapdn:             groupLdapdnVal,
		MemberAttribute:         memberAttributeVal,
		MemberOfAttribute:       memberOfAttributeVal,
		MembershipAttributeType: membershipAttributeTypeVal,
		MembershipUserAttribute: membershipUserAttributeVal,
		NameLdapattribute:       nameLdapattributeVal,
		ObjectClasses:           objectClassesVal,
		RetrievalStrategy:       retrievalStrategyVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewGroupSupportValueNull() GroupSupportValue {
	return GroupSupportValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupSupportValueUnknown() GroupSupportValue {
	return GroupSupportValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupSupportValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupSupportValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupSupportValue Attribute Value",
				"While creating a GroupSupportValue value, a missing attribute value was detected. "+
					"A GroupSupportValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupSupportValue Attribute Type",
				"While creating a GroupSupportValue value, an invalid attribute value was detected. "+
					"A GroupSupportValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupSupportValue Attribute Value",
				"While creating a GroupSupportValue value, an extra attribute value was detected. "+
					"A GroupSupportValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupSupportValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupSupportValueUnknown(), diags
	}

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	filterVal, ok := filterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.StringValue, was: %T`, filterAttribute))
	}

	groupLdapdnAttribute, ok := attributes["group_ldapdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_ldapdn is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	groupLdapdnVal, ok := groupLdapdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_ldapdn expected to be basetypes.StringValue, was: %T`, groupLdapdnAttribute))
	}

	memberAttributeAttribute, ok := attributes["member_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	memberAttributeVal, ok := memberAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_attribute expected to be basetypes.StringValue, was: %T`, memberAttributeAttribute))
	}

	memberOfAttributeAttribute, ok := attributes["member_of_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_of_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	memberOfAttributeVal, ok := memberOfAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_of_attribute expected to be basetypes.StringValue, was: %T`, memberOfAttributeAttribute))
	}

	membershipAttributeTypeAttribute, ok := attributes["membership_attribute_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_attribute_type is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	membershipAttributeTypeVal, ok := membershipAttributeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_attribute_type expected to be basetypes.StringValue, was: %T`, membershipAttributeTypeAttribute))
	}

	membershipUserAttributeAttribute, ok := attributes["membership_user_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_user_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	membershipUserAttributeVal, ok := membershipUserAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_user_attribute expected to be basetypes.StringValue, was: %T`, membershipUserAttributeAttribute))
	}

	nameLdapattributeAttribute, ok := attributes["name_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_ldapattribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	nameLdapattributeVal, ok := nameLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_ldapattribute expected to be basetypes.StringValue, was: %T`, nameLdapattributeAttribute))
	}

	objectClassesAttribute, ok := attributes["object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_classes is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	objectClassesVal, ok := objectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_classes expected to be basetypes.StringValue, was: %T`, objectClassesAttribute))
	}

	retrievalStrategyAttribute, ok := attributes["retrieval_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retrieval_strategy is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	retrievalStrategyVal, ok := retrievalStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retrieval_strategy expected to be basetypes.StringValue, was: %T`, retrievalStrategyAttribute))
	}

	if diags.HasError() {
		return NewGroupSupportValueUnknown(), diags
	}

	return GroupSupportValue{
		Filter:                  filterVal,
		GroupLdapdn:             groupLdapdnVal,
		MemberAttribute:         memberAttributeVal,
		MemberOfAttribute:       memberOfAttributeVal,
		MembershipAttributeType: membershipAttributeTypeVal,
		MembershipUserAttribute: membershipUserAttributeVal,
		NameLdapattribute:       nameLdapattributeVal,
		ObjectClasses:           objectClassesVal,
		RetrievalStrategy:       retrievalStrategyVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewGroupSupportValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupSupportValue {
	object, diags := NewGroupSupportValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupSupportValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupSupportType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupSupportValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupSupportValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupSupportValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupSupportValueMust(GroupSupportValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupSupportType) ValueType(ctx context.Context) attr.Value {
	return GroupSupportValue{}
}

var _ basetypes.ObjectValuable = GroupSupportValue{}

type GroupSupportValue struct {
	Filter                  basetypes.StringValue `tfsdk:"filter"`
	GroupLdapdn             basetypes.StringValue `tfsdk:"group_ldapdn"`
	MemberAttribute         basetypes.StringValue `tfsdk:"member_attribute"`
	MemberOfAttribute       basetypes.StringValue `tfsdk:"member_of_attribute"`
	MembershipAttributeType basetypes.StringValue `tfsdk:"membership_attribute_type"`
	MembershipUserAttribute basetypes.StringValue `tfsdk:"membership_user_attribute"`
	NameLdapattribute       basetypes.StringValue `tfsdk:"name_ldapattribute"`
	ObjectClasses           basetypes.StringValue `tfsdk:"object_classes"`
	RetrievalStrategy       basetypes.StringValue `tfsdk:"retrieval_strategy"`
	state                   attr.ValueState
}

func (v GroupSupportValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["filter"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_ldapdn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["member_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["member_of_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["membership_attribute_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["membership_user_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_ldapattribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["object_classes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["retrieval_strategy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Filter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filter"] = val

		val, err = v.GroupLdapdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_ldapdn"] = val

		val, err = v.MemberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["member_attribute"] = val

		val, err = v.MemberOfAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["member_of_attribute"] = val

		val, err = v.MembershipAttributeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["membership_attribute_type"] = val

		val, err = v.MembershipUserAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["membership_user_attribute"] = val

		val, err = v.NameLdapattribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_ldapattribute"] = val

		val, err = v.ObjectClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_classes"] = val

		val, err = v.RetrievalStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retrieval_strategy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupSupportValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupSupportValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupSupportValue) String() string {
	return "GroupSupportValue"
}

func (v GroupSupportValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"filter":                    basetypes.StringType{},
		"group_ldapdn":              basetypes.StringType{},
		"member_attribute":          basetypes.StringType{},
		"member_of_attribute":       basetypes.StringType{},
		"membership_attribute_type": basetypes.StringType{},
		"membership_user_attribute": basetypes.StringType{},
		"name_ldapattribute":        basetypes.StringType{},
		"object_classes":            basetypes.StringType{},
		"retrieval_strategy":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filter":                    v.Filter,
			"group_ldapdn":              v.GroupLdapdn,
			"member_attribute":          v.MemberAttribute,
			"member_of_attribute":       v.MemberOfAttribute,
			"membership_attribute_type": v.MembershipAttributeType,
			"membership_user_attribute": v.MembershipUserAttribute,
			"name_ldapattribute":        v.NameLdapattribute,
			"object_classes":            v.ObjectClasses,
			"retrieval_strategy":        v.RetrievalStrategy,
		})

	return objVal, diags
}

func (v GroupSupportValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupSupportValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filter.Equal(other.Filter) {
		return false
	}

	if !v.GroupLdapdn.Equal(other.GroupLdapdn) {
		return false
	}

	if !v.MemberAttribute.Equal(other.MemberAttribute) {
		return false
	}

	if !v.MemberOfAttribute.Equal(other.MemberOfAttribute) {
		return false
	}

	if !v.MembershipAttributeType.Equal(other.MembershipAttributeType) {
		return false
	}

	if !v.MembershipUserAttribute.Equal(other.MembershipUserAttribute) {
		return false
	}

	if !v.NameLdapattribute.Equal(other.NameLdapattribute) {
		return false
	}

	if !v.ObjectClasses.Equal(other.ObjectClasses) {
		return false
	}

	if !v.RetrievalStrategy.Equal(other.RetrievalStrategy) {
		return false
	}

	return true
}

func (v GroupSupportValue) Type(ctx context.Context) attr.Type {
	return GroupSupportType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupSupportValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filter":                    basetypes.StringType{},
		"group_ldapdn":              basetypes.StringType{},
		"member_attribute":          basetypes.StringType{},
		"member_of_attribute":       basetypes.StringType{},
		"membership_attribute_type": basetypes.StringType{},
		"membership_user_attribute": basetypes.StringType{},
		"name_ldapattribute":        basetypes.StringType{},
		"object_classes":            basetypes.StringType{},
		"retrieval_strategy":        basetypes.StringType{},
	}
}
