// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_store_app_summary_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func StoreAppSummaryListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"installed": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If present, this causes only installed(if true)/uninstalled(if false) applications to be returned.",
				MarkdownDescription: "If present, this causes only installed(if true)/uninstalled(if false) applications to be returned.",
			},
			"store_app_summary_list": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"app_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique ID identifying this application",
							MarkdownDescription: "Unique ID identifying this application",
						},
						"catalogs": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Catalogs where this app was found",
							MarkdownDescription: "Catalogs where this app was found",
						},
						"categories": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Application categories.",
							MarkdownDescription: "Application categories.",
						},
						"description": schema.StringAttribute{
							Computed:            true,
							Description:         "Application description that can be used for user display purposes",
							MarkdownDescription: "Application description that can be used for user display purposes",
						},
						"info_version": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"app_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The identifier for the application",
									MarkdownDescription: "The identifier for the application",
								},
								"catalog": schema.StringAttribute{
									Computed:            true,
									Description:         "The catalog in which this application version was found",
									MarkdownDescription: "The catalog in which this application version was found",
								},
								"commit_hash": schema.StringAttribute{
									Computed:            true,
									Description:         "The commit hash for the application version.",
									MarkdownDescription: "The commit hash for the application version.",
								},
								"sem_ver": schema.StringAttribute{
									Computed:            true,
									Description:         "The semantic version for the application version.",
									MarkdownDescription: "The semantic version for the application version.",
								},
							},
							CustomType: InfoVersionType{
								ObjectType: types.ObjectType{
									AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
							MarkdownDescription: "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
						},
						"info_version_metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"published_time": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the application version was published.",
									MarkdownDescription: "The date and time when the application version was published.",
								},
							},
							CustomType: InfoVersionMetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"installed": schema.BoolAttribute{
							Computed:            true,
							Description:         "\"true\" if the app is installed",
							MarkdownDescription: "\"true\" if the app is installed",
						},
						"installed_version": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"app_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The identifier for the application",
									MarkdownDescription: "The identifier for the application",
								},
								"catalog": schema.StringAttribute{
									Computed:            true,
									Description:         "The catalog in which this application version was found",
									MarkdownDescription: "The catalog in which this application version was found",
								},
								"commit_hash": schema.StringAttribute{
									Computed:            true,
									Description:         "The commit hash for the application version.",
									MarkdownDescription: "The commit hash for the application version.",
								},
								"sem_ver": schema.StringAttribute{
									Computed:            true,
									Description:         "The semantic version for the application version.",
									MarkdownDescription: "The semantic version for the application version.",
								},
							},
							CustomType: InstalledVersionType{
								ObjectType: types.ObjectType{
									AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
							MarkdownDescription: "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
						},
						"installed_version_metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"published_time": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the application version was published.",
									MarkdownDescription: "The date and time when the application version was published.",
								},
							},
							CustomType: InstalledVersionMetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"latest_version": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"app_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The identifier for the application",
									MarkdownDescription: "The identifier for the application",
								},
								"catalog": schema.StringAttribute{
									Computed:            true,
									Description:         "The catalog in which this application version was found",
									MarkdownDescription: "The catalog in which this application version was found",
								},
								"commit_hash": schema.StringAttribute{
									Computed:            true,
									Description:         "The commit hash for the application version.",
									MarkdownDescription: "The commit hash for the application version.",
								},
								"sem_ver": schema.StringAttribute{
									Computed:            true,
									Description:         "The semantic version for the application version.",
									MarkdownDescription: "The semantic version for the application version.",
								},
							},
							CustomType: LatestVersionType{
								ObjectType: types.ObjectType{
									AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
							MarkdownDescription: "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
						},
						"latest_version_metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"published_time": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the application version was published.",
									MarkdownDescription: "The date and time when the application version was published.",
								},
							},
							CustomType: LatestVersionMetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"supported_endpoints": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Application supported endpoints.",
							MarkdownDescription: "Application supported endpoints.",
						},
						"title": schema.StringAttribute{
							Computed:            true,
							Description:         "Application title that can be used for user display purposes",
							MarkdownDescription: "Application title that can be used for user display purposes",
						},
						"upgradable": schema.BoolAttribute{
							Computed:            true,
							Description:         "\"true\" if there is a new version that can be installed",
							MarkdownDescription: "\"true\" if there is a new version that can be installed",
						},
					},
					CustomType: StoreAppSummaryListType{
						ObjectType: types.ObjectType{
							AttrTypes: StoreAppSummaryListValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"upgradable": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If present, this causes only upgradable(if true)/up-to-date(if false) applications to be returned.",
				MarkdownDescription: "If present, this causes only upgradable(if true)/up-to-date(if false) applications to be returned.",
			},
		},
	}
}

type StoreAppSummaryListModel struct {
	Installed           types.Bool `tfsdk:"installed"`
	StoreAppSummaryList types.Set  `tfsdk:"store_app_summary_list"`
	Upgradable          types.Bool `tfsdk:"upgradable"`
}

var _ basetypes.ObjectTypable = StoreAppSummaryListType{}

type StoreAppSummaryListType struct {
	basetypes.ObjectType
}

func (t StoreAppSummaryListType) Equal(o attr.Type) bool {
	other, ok := o.(StoreAppSummaryListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StoreAppSummaryListType) String() string {
	return "StoreAppSummaryListType"
}

func (t StoreAppSummaryListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return nil, diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogsAttribute, ok := attributes["catalogs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalogs is missing from object`)

		return nil, diags
	}

	catalogsVal, ok := catalogsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalogs expected to be basetypes.ListValue, was: %T`, catalogsAttribute))
	}

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return nil, diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	infoVersionAttribute, ok := attributes["info_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_version is missing from object`)

		return nil, diags
	}

	infoVersionVal, ok := infoVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_version expected to be basetypes.ObjectValue, was: %T`, infoVersionAttribute))
	}

	infoVersionMetadataAttribute, ok := attributes["info_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_version_metadata is missing from object`)

		return nil, diags
	}

	infoVersionMetadataVal, ok := infoVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_version_metadata expected to be basetypes.ObjectValue, was: %T`, infoVersionMetadataAttribute))
	}

	installedAttribute, ok := attributes["installed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed is missing from object`)

		return nil, diags
	}

	installedVal, ok := installedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed expected to be basetypes.BoolValue, was: %T`, installedAttribute))
	}

	installedVersionAttribute, ok := attributes["installed_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed_version is missing from object`)

		return nil, diags
	}

	installedVersionVal, ok := installedVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed_version expected to be basetypes.ObjectValue, was: %T`, installedVersionAttribute))
	}

	installedVersionMetadataAttribute, ok := attributes["installed_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed_version_metadata is missing from object`)

		return nil, diags
	}

	installedVersionMetadataVal, ok := installedVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed_version_metadata expected to be basetypes.ObjectValue, was: %T`, installedVersionMetadataAttribute))
	}

	latestVersionAttribute, ok := attributes["latest_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_version is missing from object`)

		return nil, diags
	}

	latestVersionVal, ok := latestVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_version expected to be basetypes.ObjectValue, was: %T`, latestVersionAttribute))
	}

	latestVersionMetadataAttribute, ok := attributes["latest_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_version_metadata is missing from object`)

		return nil, diags
	}

	latestVersionMetadataVal, ok := latestVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_version_metadata expected to be basetypes.ObjectValue, was: %T`, latestVersionMetadataAttribute))
	}

	supportedEndpointsAttribute, ok := attributes["supported_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported_endpoints is missing from object`)

		return nil, diags
	}

	supportedEndpointsVal, ok := supportedEndpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported_endpoints expected to be basetypes.ListValue, was: %T`, supportedEndpointsAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	upgradableAttribute, ok := attributes["upgradable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upgradable is missing from object`)

		return nil, diags
	}

	upgradableVal, ok := upgradableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upgradable expected to be basetypes.BoolValue, was: %T`, upgradableAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StoreAppSummaryListValue{
		AppId:                    appIdVal,
		Catalogs:                 catalogsVal,
		Categories:               categoriesVal,
		Description:              descriptionVal,
		InfoVersion:              infoVersionVal,
		InfoVersionMetadata:      infoVersionMetadataVal,
		Installed:                installedVal,
		InstalledVersion:         installedVersionVal,
		InstalledVersionMetadata: installedVersionMetadataVal,
		LatestVersion:            latestVersionVal,
		LatestVersionMetadata:    latestVersionMetadataVal,
		SupportedEndpoints:       supportedEndpointsVal,
		Title:                    titleVal,
		Upgradable:               upgradableVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewStoreAppSummaryListValueNull() StoreAppSummaryListValue {
	return StoreAppSummaryListValue{
		state: attr.ValueStateNull,
	}
}

func NewStoreAppSummaryListValueUnknown() StoreAppSummaryListValue {
	return StoreAppSummaryListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStoreAppSummaryListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StoreAppSummaryListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StoreAppSummaryListValue Attribute Value",
				"While creating a StoreAppSummaryListValue value, a missing attribute value was detected. "+
					"A StoreAppSummaryListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StoreAppSummaryListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StoreAppSummaryListValue Attribute Type",
				"While creating a StoreAppSummaryListValue value, an invalid attribute value was detected. "+
					"A StoreAppSummaryListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StoreAppSummaryListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StoreAppSummaryListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StoreAppSummaryListValue Attribute Value",
				"While creating a StoreAppSummaryListValue value, an extra attribute value was detected. "+
					"A StoreAppSummaryListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StoreAppSummaryListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStoreAppSummaryListValueUnknown(), diags
	}

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogsAttribute, ok := attributes["catalogs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalogs is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	catalogsVal, ok := catalogsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalogs expected to be basetypes.ListValue, was: %T`, catalogsAttribute))
	}

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	infoVersionAttribute, ok := attributes["info_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_version is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	infoVersionVal, ok := infoVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_version expected to be basetypes.ObjectValue, was: %T`, infoVersionAttribute))
	}

	infoVersionMetadataAttribute, ok := attributes["info_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_version_metadata is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	infoVersionMetadataVal, ok := infoVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_version_metadata expected to be basetypes.ObjectValue, was: %T`, infoVersionMetadataAttribute))
	}

	installedAttribute, ok := attributes["installed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	installedVal, ok := installedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed expected to be basetypes.BoolValue, was: %T`, installedAttribute))
	}

	installedVersionAttribute, ok := attributes["installed_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed_version is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	installedVersionVal, ok := installedVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed_version expected to be basetypes.ObjectValue, was: %T`, installedVersionAttribute))
	}

	installedVersionMetadataAttribute, ok := attributes["installed_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installed_version_metadata is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	installedVersionMetadataVal, ok := installedVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installed_version_metadata expected to be basetypes.ObjectValue, was: %T`, installedVersionMetadataAttribute))
	}

	latestVersionAttribute, ok := attributes["latest_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_version is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	latestVersionVal, ok := latestVersionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_version expected to be basetypes.ObjectValue, was: %T`, latestVersionAttribute))
	}

	latestVersionMetadataAttribute, ok := attributes["latest_version_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_version_metadata is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	latestVersionMetadataVal, ok := latestVersionMetadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_version_metadata expected to be basetypes.ObjectValue, was: %T`, latestVersionMetadataAttribute))
	}

	supportedEndpointsAttribute, ok := attributes["supported_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supported_endpoints is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	supportedEndpointsVal, ok := supportedEndpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supported_endpoints expected to be basetypes.ListValue, was: %T`, supportedEndpointsAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	upgradableAttribute, ok := attributes["upgradable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upgradable is missing from object`)

		return NewStoreAppSummaryListValueUnknown(), diags
	}

	upgradableVal, ok := upgradableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upgradable expected to be basetypes.BoolValue, was: %T`, upgradableAttribute))
	}

	if diags.HasError() {
		return NewStoreAppSummaryListValueUnknown(), diags
	}

	return StoreAppSummaryListValue{
		AppId:                    appIdVal,
		Catalogs:                 catalogsVal,
		Categories:               categoriesVal,
		Description:              descriptionVal,
		InfoVersion:              infoVersionVal,
		InfoVersionMetadata:      infoVersionMetadataVal,
		Installed:                installedVal,
		InstalledVersion:         installedVersionVal,
		InstalledVersionMetadata: installedVersionMetadataVal,
		LatestVersion:            latestVersionVal,
		LatestVersionMetadata:    latestVersionMetadataVal,
		SupportedEndpoints:       supportedEndpointsVal,
		Title:                    titleVal,
		Upgradable:               upgradableVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewStoreAppSummaryListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StoreAppSummaryListValue {
	object, diags := NewStoreAppSummaryListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStoreAppSummaryListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StoreAppSummaryListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStoreAppSummaryListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStoreAppSummaryListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStoreAppSummaryListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStoreAppSummaryListValueMust(StoreAppSummaryListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StoreAppSummaryListType) ValueType(ctx context.Context) attr.Value {
	return StoreAppSummaryListValue{}
}

var _ basetypes.ObjectValuable = StoreAppSummaryListValue{}

type StoreAppSummaryListValue struct {
	AppId                    basetypes.StringValue `tfsdk:"app_id"`
	Catalogs                 basetypes.ListValue   `tfsdk:"catalogs"`
	Categories               basetypes.ListValue   `tfsdk:"categories"`
	Description              basetypes.StringValue `tfsdk:"description"`
	InfoVersion              basetypes.ObjectValue `tfsdk:"info_version"`
	InfoVersionMetadata      basetypes.ObjectValue `tfsdk:"info_version_metadata"`
	Installed                basetypes.BoolValue   `tfsdk:"installed"`
	InstalledVersion         basetypes.ObjectValue `tfsdk:"installed_version"`
	InstalledVersionMetadata basetypes.ObjectValue `tfsdk:"installed_version_metadata"`
	LatestVersion            basetypes.ObjectValue `tfsdk:"latest_version"`
	LatestVersionMetadata    basetypes.ObjectValue `tfsdk:"latest_version_metadata"`
	SupportedEndpoints       basetypes.ListValue   `tfsdk:"supported_endpoints"`
	Title                    basetypes.StringValue `tfsdk:"title"`
	Upgradable               basetypes.BoolValue   `tfsdk:"upgradable"`
	state                    attr.ValueState
}

func (v StoreAppSummaryListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["app_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["catalogs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["categories"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["info_version"] = basetypes.ObjectType{
		AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["info_version_metadata"] = basetypes.ObjectType{
		AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["installed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["installed_version"] = basetypes.ObjectType{
		AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["installed_version_metadata"] = basetypes.ObjectType{
		AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["latest_version"] = basetypes.ObjectType{
		AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["latest_version_metadata"] = basetypes.ObjectType{
		AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["supported_endpoints"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["upgradable"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AppId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_id"] = val

		val, err = v.Catalogs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalogs"] = val

		val, err = v.Categories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["categories"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.InfoVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info_version"] = val

		val, err = v.InfoVersionMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info_version_metadata"] = val

		val, err = v.Installed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["installed"] = val

		val, err = v.InstalledVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["installed_version"] = val

		val, err = v.InstalledVersionMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["installed_version_metadata"] = val

		val, err = v.LatestVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latest_version"] = val

		val, err = v.LatestVersionMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latest_version_metadata"] = val

		val, err = v.SupportedEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supported_endpoints"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.Upgradable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upgradable"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StoreAppSummaryListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StoreAppSummaryListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StoreAppSummaryListValue) String() string {
	return "StoreAppSummaryListValue"
}

func (v StoreAppSummaryListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var infoVersion basetypes.ObjectValue

	if v.InfoVersion.IsNull() {
		infoVersion = types.ObjectNull(
			InfoVersionValue{}.AttributeTypes(ctx),
		)
	}

	if v.InfoVersion.IsUnknown() {
		infoVersion = types.ObjectUnknown(
			InfoVersionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InfoVersion.IsNull() && !v.InfoVersion.IsUnknown() {
		infoVersion = types.ObjectValueMust(
			InfoVersionValue{}.AttributeTypes(ctx),
			v.InfoVersion.Attributes(),
		)
	}

	var infoVersionMetadata basetypes.ObjectValue

	if v.InfoVersionMetadata.IsNull() {
		infoVersionMetadata = types.ObjectNull(
			InfoVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.InfoVersionMetadata.IsUnknown() {
		infoVersionMetadata = types.ObjectUnknown(
			InfoVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InfoVersionMetadata.IsNull() && !v.InfoVersionMetadata.IsUnknown() {
		infoVersionMetadata = types.ObjectValueMust(
			InfoVersionMetadataValue{}.AttributeTypes(ctx),
			v.InfoVersionMetadata.Attributes(),
		)
	}

	var installedVersion basetypes.ObjectValue

	if v.InstalledVersion.IsNull() {
		installedVersion = types.ObjectNull(
			InstalledVersionValue{}.AttributeTypes(ctx),
		)
	}

	if v.InstalledVersion.IsUnknown() {
		installedVersion = types.ObjectUnknown(
			InstalledVersionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InstalledVersion.IsNull() && !v.InstalledVersion.IsUnknown() {
		installedVersion = types.ObjectValueMust(
			InstalledVersionValue{}.AttributeTypes(ctx),
			v.InstalledVersion.Attributes(),
		)
	}

	var installedVersionMetadata basetypes.ObjectValue

	if v.InstalledVersionMetadata.IsNull() {
		installedVersionMetadata = types.ObjectNull(
			InstalledVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.InstalledVersionMetadata.IsUnknown() {
		installedVersionMetadata = types.ObjectUnknown(
			InstalledVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InstalledVersionMetadata.IsNull() && !v.InstalledVersionMetadata.IsUnknown() {
		installedVersionMetadata = types.ObjectValueMust(
			InstalledVersionMetadataValue{}.AttributeTypes(ctx),
			v.InstalledVersionMetadata.Attributes(),
		)
	}

	var latestVersion basetypes.ObjectValue

	if v.LatestVersion.IsNull() {
		latestVersion = types.ObjectNull(
			LatestVersionValue{}.AttributeTypes(ctx),
		)
	}

	if v.LatestVersion.IsUnknown() {
		latestVersion = types.ObjectUnknown(
			LatestVersionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LatestVersion.IsNull() && !v.LatestVersion.IsUnknown() {
		latestVersion = types.ObjectValueMust(
			LatestVersionValue{}.AttributeTypes(ctx),
			v.LatestVersion.Attributes(),
		)
	}

	var latestVersionMetadata basetypes.ObjectValue

	if v.LatestVersionMetadata.IsNull() {
		latestVersionMetadata = types.ObjectNull(
			LatestVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.LatestVersionMetadata.IsUnknown() {
		latestVersionMetadata = types.ObjectUnknown(
			LatestVersionMetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LatestVersionMetadata.IsNull() && !v.LatestVersionMetadata.IsUnknown() {
		latestVersionMetadata = types.ObjectValueMust(
			LatestVersionMetadataValue{}.AttributeTypes(ctx),
			v.LatestVersionMetadata.Attributes(),
		)
	}

	var catalogsVal basetypes.ListValue
	switch {
	case v.Catalogs.IsUnknown():
		catalogsVal = types.ListUnknown(types.StringType)
	case v.Catalogs.IsNull():
		catalogsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		catalogsVal, d = types.ListValue(types.StringType, v.Catalogs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"app_id": basetypes.StringType{},
			"catalogs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"info_version": basetypes.ObjectType{
				AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
			},
			"info_version_metadata": basetypes.ObjectType{
				AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"installed": basetypes.BoolType{},
			"installed_version": basetypes.ObjectType{
				AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
			},
			"installed_version_metadata": basetypes.ObjectType{
				AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"latest_version": basetypes.ObjectType{
				AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
			},
			"latest_version_metadata": basetypes.ObjectType{
				AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"supported_endpoints": basetypes.ListType{
				ElemType: types.StringType,
			},
			"title":      basetypes.StringType{},
			"upgradable": basetypes.BoolType{},
		}), diags
	}

	var categoriesVal basetypes.ListValue
	switch {
	case v.Categories.IsUnknown():
		categoriesVal = types.ListUnknown(types.StringType)
	case v.Categories.IsNull():
		categoriesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		categoriesVal, d = types.ListValue(types.StringType, v.Categories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"app_id": basetypes.StringType{},
			"catalogs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"info_version": basetypes.ObjectType{
				AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
			},
			"info_version_metadata": basetypes.ObjectType{
				AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"installed": basetypes.BoolType{},
			"installed_version": basetypes.ObjectType{
				AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
			},
			"installed_version_metadata": basetypes.ObjectType{
				AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"latest_version": basetypes.ObjectType{
				AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
			},
			"latest_version_metadata": basetypes.ObjectType{
				AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"supported_endpoints": basetypes.ListType{
				ElemType: types.StringType,
			},
			"title":      basetypes.StringType{},
			"upgradable": basetypes.BoolType{},
		}), diags
	}

	var supportedEndpointsVal basetypes.ListValue
	switch {
	case v.SupportedEndpoints.IsUnknown():
		supportedEndpointsVal = types.ListUnknown(types.StringType)
	case v.SupportedEndpoints.IsNull():
		supportedEndpointsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		supportedEndpointsVal, d = types.ListValue(types.StringType, v.SupportedEndpoints.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"app_id": basetypes.StringType{},
			"catalogs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"info_version": basetypes.ObjectType{
				AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
			},
			"info_version_metadata": basetypes.ObjectType{
				AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"installed": basetypes.BoolType{},
			"installed_version": basetypes.ObjectType{
				AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
			},
			"installed_version_metadata": basetypes.ObjectType{
				AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"latest_version": basetypes.ObjectType{
				AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
			},
			"latest_version_metadata": basetypes.ObjectType{
				AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
			},
			"supported_endpoints": basetypes.ListType{
				ElemType: types.StringType,
			},
			"title":      basetypes.StringType{},
			"upgradable": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"app_id": basetypes.StringType{},
		"catalogs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"description": basetypes.StringType{},
		"info_version": basetypes.ObjectType{
			AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
		},
		"info_version_metadata": basetypes.ObjectType{
			AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"installed": basetypes.BoolType{},
		"installed_version": basetypes.ObjectType{
			AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
		},
		"installed_version_metadata": basetypes.ObjectType{
			AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"latest_version": basetypes.ObjectType{
			AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
		},
		"latest_version_metadata": basetypes.ObjectType{
			AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"supported_endpoints": basetypes.ListType{
			ElemType: types.StringType,
		},
		"title":      basetypes.StringType{},
		"upgradable": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"app_id":                     v.AppId,
			"catalogs":                   catalogsVal,
			"categories":                 categoriesVal,
			"description":                v.Description,
			"info_version":               infoVersion,
			"info_version_metadata":      infoVersionMetadata,
			"installed":                  v.Installed,
			"installed_version":          installedVersion,
			"installed_version_metadata": installedVersionMetadata,
			"latest_version":             latestVersion,
			"latest_version_metadata":    latestVersionMetadata,
			"supported_endpoints":        supportedEndpointsVal,
			"title":                      v.Title,
			"upgradable":                 v.Upgradable,
		})

	return objVal, diags
}

func (v StoreAppSummaryListValue) Equal(o attr.Value) bool {
	other, ok := o.(StoreAppSummaryListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppId.Equal(other.AppId) {
		return false
	}

	if !v.Catalogs.Equal(other.Catalogs) {
		return false
	}

	if !v.Categories.Equal(other.Categories) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.InfoVersion.Equal(other.InfoVersion) {
		return false
	}

	if !v.InfoVersionMetadata.Equal(other.InfoVersionMetadata) {
		return false
	}

	if !v.Installed.Equal(other.Installed) {
		return false
	}

	if !v.InstalledVersion.Equal(other.InstalledVersion) {
		return false
	}

	if !v.InstalledVersionMetadata.Equal(other.InstalledVersionMetadata) {
		return false
	}

	if !v.LatestVersion.Equal(other.LatestVersion) {
		return false
	}

	if !v.LatestVersionMetadata.Equal(other.LatestVersionMetadata) {
		return false
	}

	if !v.SupportedEndpoints.Equal(other.SupportedEndpoints) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.Upgradable.Equal(other.Upgradable) {
		return false
	}

	return true
}

func (v StoreAppSummaryListValue) Type(ctx context.Context) attr.Type {
	return StoreAppSummaryListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StoreAppSummaryListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"app_id": basetypes.StringType{},
		"catalogs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"description": basetypes.StringType{},
		"info_version": basetypes.ObjectType{
			AttrTypes: InfoVersionValue{}.AttributeTypes(ctx),
		},
		"info_version_metadata": basetypes.ObjectType{
			AttrTypes: InfoVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"installed": basetypes.BoolType{},
		"installed_version": basetypes.ObjectType{
			AttrTypes: InstalledVersionValue{}.AttributeTypes(ctx),
		},
		"installed_version_metadata": basetypes.ObjectType{
			AttrTypes: InstalledVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"latest_version": basetypes.ObjectType{
			AttrTypes: LatestVersionValue{}.AttributeTypes(ctx),
		},
		"latest_version_metadata": basetypes.ObjectType{
			AttrTypes: LatestVersionMetadataValue{}.AttributeTypes(ctx),
		},
		"supported_endpoints": basetypes.ListType{
			ElemType: types.StringType,
		},
		"title":      basetypes.StringType{},
		"upgradable": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InfoVersionType{}

type InfoVersionType struct {
	basetypes.ObjectType
}

func (t InfoVersionType) Equal(o attr.Type) bool {
	other, ok := o.(InfoVersionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoVersionType) String() string {
	return "InfoVersionType"
}

func (t InfoVersionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return nil, diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return nil, diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return nil, diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInfoVersionValueNull() InfoVersionValue {
	return InfoVersionValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoVersionValueUnknown() InfoVersionValue {
	return InfoVersionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoVersionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoVersionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoVersionValue Attribute Value",
				"While creating a InfoVersionValue value, a missing attribute value was detected. "+
					"A InfoVersionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoVersionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoVersionValue Attribute Type",
				"While creating a InfoVersionValue value, an invalid attribute value was detected. "+
					"A InfoVersionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoVersionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoVersionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoVersionValue Attribute Value",
				"While creating a InfoVersionValue value, an extra attribute value was detected. "+
					"A InfoVersionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoVersionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoVersionValueUnknown(), diags
	}

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return NewInfoVersionValueUnknown(), diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewInfoVersionValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return NewInfoVersionValueUnknown(), diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return NewInfoVersionValueUnknown(), diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return NewInfoVersionValueUnknown(), diags
	}

	return InfoVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInfoVersionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoVersionValue {
	object, diags := NewInfoVersionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoVersionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoVersionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoVersionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoVersionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoVersionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoVersionValueMust(InfoVersionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoVersionType) ValueType(ctx context.Context) attr.Value {
	return InfoVersionValue{}
}

var _ basetypes.ObjectValuable = InfoVersionValue{}

type InfoVersionValue struct {
	AppId      basetypes.StringValue `tfsdk:"app_id"`
	Catalog    basetypes.StringValue `tfsdk:"catalog"`
	CommitHash basetypes.StringValue `tfsdk:"commit_hash"`
	SemVer     basetypes.StringValue `tfsdk:"sem_ver"`
	state      attr.ValueState
}

func (v InfoVersionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["app_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["commit_hash"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sem_ver"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AppId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_id"] = val

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.CommitHash.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["commit_hash"] = val

		val, err = v.SemVer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sem_ver"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoVersionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoVersionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoVersionValue) String() string {
	return "InfoVersionValue"
}

func (v InfoVersionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"app_id":      v.AppId,
			"catalog":     v.Catalog,
			"commit_hash": v.CommitHash,
			"sem_ver":     v.SemVer,
		})

	return objVal, diags
}

func (v InfoVersionValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoVersionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppId.Equal(other.AppId) {
		return false
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.CommitHash.Equal(other.CommitHash) {
		return false
	}

	if !v.SemVer.Equal(other.SemVer) {
		return false
	}

	return true
}

func (v InfoVersionValue) Type(ctx context.Context) attr.Type {
	return InfoVersionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoVersionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InfoVersionMetadataType{}

type InfoVersionMetadataType struct {
	basetypes.ObjectType
}

func (t InfoVersionMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(InfoVersionMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoVersionMetadataType) String() string {
	return "InfoVersionMetadataType"
}

func (t InfoVersionMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return nil, diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewInfoVersionMetadataValueNull() InfoVersionMetadataValue {
	return InfoVersionMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoVersionMetadataValueUnknown() InfoVersionMetadataValue {
	return InfoVersionMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoVersionMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoVersionMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoVersionMetadataValue Attribute Value",
				"While creating a InfoVersionMetadataValue value, a missing attribute value was detected. "+
					"A InfoVersionMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoVersionMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoVersionMetadataValue Attribute Type",
				"While creating a InfoVersionMetadataValue value, an invalid attribute value was detected. "+
					"A InfoVersionMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoVersionMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoVersionMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoVersionMetadataValue Attribute Value",
				"While creating a InfoVersionMetadataValue value, an extra attribute value was detected. "+
					"A InfoVersionMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoVersionMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoVersionMetadataValueUnknown(), diags
	}

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return NewInfoVersionMetadataValueUnknown(), diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return NewInfoVersionMetadataValueUnknown(), diags
	}

	return InfoVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewInfoVersionMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoVersionMetadataValue {
	object, diags := NewInfoVersionMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoVersionMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoVersionMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoVersionMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoVersionMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoVersionMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoVersionMetadataValueMust(InfoVersionMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoVersionMetadataType) ValueType(ctx context.Context) attr.Value {
	return InfoVersionMetadataValue{}
}

var _ basetypes.ObjectValuable = InfoVersionMetadataValue{}

type InfoVersionMetadataValue struct {
	PublishedTime basetypes.StringValue `tfsdk:"published_time"`
	state         attr.ValueState
}

func (v InfoVersionMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["published_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PublishedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["published_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoVersionMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoVersionMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoVersionMetadataValue) String() string {
	return "InfoVersionMetadataValue"
}

func (v InfoVersionMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"published_time": v.PublishedTime,
		})

	return objVal, diags
}

func (v InfoVersionMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoVersionMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PublishedTime.Equal(other.PublishedTime) {
		return false
	}

	return true
}

func (v InfoVersionMetadataValue) Type(ctx context.Context) attr.Type {
	return InfoVersionMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoVersionMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstalledVersionType{}

type InstalledVersionType struct {
	basetypes.ObjectType
}

func (t InstalledVersionType) Equal(o attr.Type) bool {
	other, ok := o.(InstalledVersionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstalledVersionType) String() string {
	return "InstalledVersionType"
}

func (t InstalledVersionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return nil, diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return nil, diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return nil, diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstalledVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInstalledVersionValueNull() InstalledVersionValue {
	return InstalledVersionValue{
		state: attr.ValueStateNull,
	}
}

func NewInstalledVersionValueUnknown() InstalledVersionValue {
	return InstalledVersionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstalledVersionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstalledVersionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstalledVersionValue Attribute Value",
				"While creating a InstalledVersionValue value, a missing attribute value was detected. "+
					"A InstalledVersionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstalledVersionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstalledVersionValue Attribute Type",
				"While creating a InstalledVersionValue value, an invalid attribute value was detected. "+
					"A InstalledVersionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstalledVersionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstalledVersionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstalledVersionValue Attribute Value",
				"While creating a InstalledVersionValue value, an extra attribute value was detected. "+
					"A InstalledVersionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstalledVersionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstalledVersionValueUnknown(), diags
	}

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return NewInstalledVersionValueUnknown(), diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewInstalledVersionValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return NewInstalledVersionValueUnknown(), diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return NewInstalledVersionValueUnknown(), diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return NewInstalledVersionValueUnknown(), diags
	}

	return InstalledVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInstalledVersionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstalledVersionValue {
	object, diags := NewInstalledVersionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstalledVersionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstalledVersionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstalledVersionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstalledVersionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstalledVersionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstalledVersionValueMust(InstalledVersionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstalledVersionType) ValueType(ctx context.Context) attr.Value {
	return InstalledVersionValue{}
}

var _ basetypes.ObjectValuable = InstalledVersionValue{}

type InstalledVersionValue struct {
	AppId      basetypes.StringValue `tfsdk:"app_id"`
	Catalog    basetypes.StringValue `tfsdk:"catalog"`
	CommitHash basetypes.StringValue `tfsdk:"commit_hash"`
	SemVer     basetypes.StringValue `tfsdk:"sem_ver"`
	state      attr.ValueState
}

func (v InstalledVersionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["app_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["commit_hash"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sem_ver"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AppId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_id"] = val

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.CommitHash.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["commit_hash"] = val

		val, err = v.SemVer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sem_ver"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstalledVersionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstalledVersionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstalledVersionValue) String() string {
	return "InstalledVersionValue"
}

func (v InstalledVersionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"app_id":      v.AppId,
			"catalog":     v.Catalog,
			"commit_hash": v.CommitHash,
			"sem_ver":     v.SemVer,
		})

	return objVal, diags
}

func (v InstalledVersionValue) Equal(o attr.Value) bool {
	other, ok := o.(InstalledVersionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppId.Equal(other.AppId) {
		return false
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.CommitHash.Equal(other.CommitHash) {
		return false
	}

	if !v.SemVer.Equal(other.SemVer) {
		return false
	}

	return true
}

func (v InstalledVersionValue) Type(ctx context.Context) attr.Type {
	return InstalledVersionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstalledVersionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstalledVersionMetadataType{}

type InstalledVersionMetadataType struct {
	basetypes.ObjectType
}

func (t InstalledVersionMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(InstalledVersionMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstalledVersionMetadataType) String() string {
	return "InstalledVersionMetadataType"
}

func (t InstalledVersionMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return nil, diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstalledVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewInstalledVersionMetadataValueNull() InstalledVersionMetadataValue {
	return InstalledVersionMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewInstalledVersionMetadataValueUnknown() InstalledVersionMetadataValue {
	return InstalledVersionMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstalledVersionMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstalledVersionMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstalledVersionMetadataValue Attribute Value",
				"While creating a InstalledVersionMetadataValue value, a missing attribute value was detected. "+
					"A InstalledVersionMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstalledVersionMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstalledVersionMetadataValue Attribute Type",
				"While creating a InstalledVersionMetadataValue value, an invalid attribute value was detected. "+
					"A InstalledVersionMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstalledVersionMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstalledVersionMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstalledVersionMetadataValue Attribute Value",
				"While creating a InstalledVersionMetadataValue value, an extra attribute value was detected. "+
					"A InstalledVersionMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstalledVersionMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstalledVersionMetadataValueUnknown(), diags
	}

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return NewInstalledVersionMetadataValueUnknown(), diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return NewInstalledVersionMetadataValueUnknown(), diags
	}

	return InstalledVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewInstalledVersionMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstalledVersionMetadataValue {
	object, diags := NewInstalledVersionMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstalledVersionMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstalledVersionMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstalledVersionMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstalledVersionMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstalledVersionMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstalledVersionMetadataValueMust(InstalledVersionMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstalledVersionMetadataType) ValueType(ctx context.Context) attr.Value {
	return InstalledVersionMetadataValue{}
}

var _ basetypes.ObjectValuable = InstalledVersionMetadataValue{}

type InstalledVersionMetadataValue struct {
	PublishedTime basetypes.StringValue `tfsdk:"published_time"`
	state         attr.ValueState
}

func (v InstalledVersionMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["published_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PublishedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["published_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstalledVersionMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstalledVersionMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstalledVersionMetadataValue) String() string {
	return "InstalledVersionMetadataValue"
}

func (v InstalledVersionMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"published_time": v.PublishedTime,
		})

	return objVal, diags
}

func (v InstalledVersionMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(InstalledVersionMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PublishedTime.Equal(other.PublishedTime) {
		return false
	}

	return true
}

func (v InstalledVersionMetadataValue) Type(ctx context.Context) attr.Type {
	return InstalledVersionMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstalledVersionMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LatestVersionType{}

type LatestVersionType struct {
	basetypes.ObjectType
}

func (t LatestVersionType) Equal(o attr.Type) bool {
	other, ok := o.(LatestVersionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LatestVersionType) String() string {
	return "LatestVersionType"
}

func (t LatestVersionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return nil, diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return nil, diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return nil, diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LatestVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLatestVersionValueNull() LatestVersionValue {
	return LatestVersionValue{
		state: attr.ValueStateNull,
	}
}

func NewLatestVersionValueUnknown() LatestVersionValue {
	return LatestVersionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLatestVersionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LatestVersionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LatestVersionValue Attribute Value",
				"While creating a LatestVersionValue value, a missing attribute value was detected. "+
					"A LatestVersionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestVersionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LatestVersionValue Attribute Type",
				"While creating a LatestVersionValue value, an invalid attribute value was detected. "+
					"A LatestVersionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestVersionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LatestVersionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LatestVersionValue Attribute Value",
				"While creating a LatestVersionValue value, an extra attribute value was detected. "+
					"A LatestVersionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LatestVersionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLatestVersionValueUnknown(), diags
	}

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return NewLatestVersionValueUnknown(), diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewLatestVersionValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	commitHashAttribute, ok := attributes["commit_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`commit_hash is missing from object`)

		return NewLatestVersionValueUnknown(), diags
	}

	commitHashVal, ok := commitHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`commit_hash expected to be basetypes.StringValue, was: %T`, commitHashAttribute))
	}

	semVerAttribute, ok := attributes["sem_ver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sem_ver is missing from object`)

		return NewLatestVersionValueUnknown(), diags
	}

	semVerVal, ok := semVerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sem_ver expected to be basetypes.StringValue, was: %T`, semVerAttribute))
	}

	if diags.HasError() {
		return NewLatestVersionValueUnknown(), diags
	}

	return LatestVersionValue{
		AppId:      appIdVal,
		Catalog:    catalogVal,
		CommitHash: commitHashVal,
		SemVer:     semVerVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLatestVersionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LatestVersionValue {
	object, diags := NewLatestVersionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLatestVersionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LatestVersionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLatestVersionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLatestVersionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLatestVersionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLatestVersionValueMust(LatestVersionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LatestVersionType) ValueType(ctx context.Context) attr.Value {
	return LatestVersionValue{}
}

var _ basetypes.ObjectValuable = LatestVersionValue{}

type LatestVersionValue struct {
	AppId      basetypes.StringValue `tfsdk:"app_id"`
	Catalog    basetypes.StringValue `tfsdk:"catalog"`
	CommitHash basetypes.StringValue `tfsdk:"commit_hash"`
	SemVer     basetypes.StringValue `tfsdk:"sem_ver"`
	state      attr.ValueState
}

func (v LatestVersionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["app_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["commit_hash"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sem_ver"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AppId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_id"] = val

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.CommitHash.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["commit_hash"] = val

		val, err = v.SemVer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sem_ver"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LatestVersionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LatestVersionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LatestVersionValue) String() string {
	return "LatestVersionValue"
}

func (v LatestVersionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"app_id":      v.AppId,
			"catalog":     v.Catalog,
			"commit_hash": v.CommitHash,
			"sem_ver":     v.SemVer,
		})

	return objVal, diags
}

func (v LatestVersionValue) Equal(o attr.Value) bool {
	other, ok := o.(LatestVersionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppId.Equal(other.AppId) {
		return false
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.CommitHash.Equal(other.CommitHash) {
		return false
	}

	if !v.SemVer.Equal(other.SemVer) {
		return false
	}

	return true
}

func (v LatestVersionValue) Type(ctx context.Context) attr.Type {
	return LatestVersionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LatestVersionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"app_id":      basetypes.StringType{},
		"catalog":     basetypes.StringType{},
		"commit_hash": basetypes.StringType{},
		"sem_ver":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LatestVersionMetadataType{}

type LatestVersionMetadataType struct {
	basetypes.ObjectType
}

func (t LatestVersionMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(LatestVersionMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LatestVersionMetadataType) String() string {
	return "LatestVersionMetadataType"
}

func (t LatestVersionMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return nil, diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LatestVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewLatestVersionMetadataValueNull() LatestVersionMetadataValue {
	return LatestVersionMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewLatestVersionMetadataValueUnknown() LatestVersionMetadataValue {
	return LatestVersionMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLatestVersionMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LatestVersionMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LatestVersionMetadataValue Attribute Value",
				"While creating a LatestVersionMetadataValue value, a missing attribute value was detected. "+
					"A LatestVersionMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestVersionMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LatestVersionMetadataValue Attribute Type",
				"While creating a LatestVersionMetadataValue value, an invalid attribute value was detected. "+
					"A LatestVersionMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestVersionMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LatestVersionMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LatestVersionMetadataValue Attribute Value",
				"While creating a LatestVersionMetadataValue value, an extra attribute value was detected. "+
					"A LatestVersionMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LatestVersionMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLatestVersionMetadataValueUnknown(), diags
	}

	publishedTimeAttribute, ok := attributes["published_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`published_time is missing from object`)

		return NewLatestVersionMetadataValueUnknown(), diags
	}

	publishedTimeVal, ok := publishedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`published_time expected to be basetypes.StringValue, was: %T`, publishedTimeAttribute))
	}

	if diags.HasError() {
		return NewLatestVersionMetadataValueUnknown(), diags
	}

	return LatestVersionMetadataValue{
		PublishedTime: publishedTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewLatestVersionMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LatestVersionMetadataValue {
	object, diags := NewLatestVersionMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLatestVersionMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LatestVersionMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLatestVersionMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLatestVersionMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLatestVersionMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLatestVersionMetadataValueMust(LatestVersionMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LatestVersionMetadataType) ValueType(ctx context.Context) attr.Value {
	return LatestVersionMetadataValue{}
}

var _ basetypes.ObjectValuable = LatestVersionMetadataValue{}

type LatestVersionMetadataValue struct {
	PublishedTime basetypes.StringValue `tfsdk:"published_time"`
	state         attr.ValueState
}

func (v LatestVersionMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["published_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PublishedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["published_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LatestVersionMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LatestVersionMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LatestVersionMetadataValue) String() string {
	return "LatestVersionMetadataValue"
}

func (v LatestVersionMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"published_time": v.PublishedTime,
		})

	return objVal, diags
}

func (v LatestVersionMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(LatestVersionMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PublishedTime.Equal(other.PublishedTime) {
		return false
	}

	return true
}

func (v LatestVersionMetadataValue) Type(ctx context.Context) attr.Type {
	return LatestVersionMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LatestVersionMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"published_time": basetypes.StringType{},
	}
}
