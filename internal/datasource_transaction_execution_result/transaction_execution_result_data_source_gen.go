// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_transaction_execution_result

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func TransactionExecutionResultDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"changed_crs": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"gvk": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"group": schema.StringAttribute{
									Computed:            true,
									Description:         "Name of the API group",
									MarkdownDescription: "Name of the API group",
								},
								"kind": schema.StringAttribute{
									Computed:            true,
									Description:         "The Kind of the resource",
									MarkdownDescription: "The Kind of the resource",
								},
								"version": schema.StringAttribute{
									Computed:            true,
									Description:         "Version of the API group",
									MarkdownDescription: "Version of the API group",
								},
							},
							CustomType: GvkType{
								ObjectType: types.ObjectType{
									AttrTypes: GvkValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"names": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"namespace": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ChangedCrsType{
						ObjectType: types.ObjectType{
							AttrTypes: ChangedCrsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "List of changed CRs as part of the transaction",
				MarkdownDescription: "List of changed CRs as part of the transaction",
			},
			"execution_summary": schema.StringAttribute{
				Computed:            true,
				Description:         "Information about time taken during processing",
				MarkdownDescription: "Information about time taken during processing",
			},
			"fail_on_errors": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Flag to tell the request to fail if the transaction has errors.  By default it will not fail.",
				MarkdownDescription: "Flag to tell the request to fail if the transaction has errors.  By default it will not fail.",
			},
			"general_errors": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "List of general errors while running the transaction",
				MarkdownDescription: "List of general errors while running the transaction",
			},
			"intents_run": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"errors": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"raw_error": schema.StringAttribute{
										Computed: true,
									},
									"structured_error": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"message": schema.StringAttribute{
												Computed: true,
											},
											"message_key": schema.StringAttribute{
												Computed: true,
											},
											"values": schema.MapNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{},
													CustomType: ValuesType{
														ObjectType: types.ObjectType{
															AttrTypes: ValuesValue{}.AttributeTypes(ctx),
														},
													},
												},
												Computed: true,
											},
										},
										CustomType: StructuredErrorType{
											ObjectType: types.ObjectType{
												AttrTypes: StructuredErrorValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
								},
								CustomType: ErrorsType{
									ObjectType: types.ObjectType{
										AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"intent_name": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"gvk_1": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"group": schema.StringAttribute{
											Computed:            true,
											Description:         "Name of the API group",
											MarkdownDescription: "Name of the API group",
										},
										"kind": schema.StringAttribute{
											Computed:            true,
											Description:         "The Kind of the resource",
											MarkdownDescription: "The Kind of the resource",
										},
										"version": schema.StringAttribute{
											Computed:            true,
											Description:         "Version of the API group",
											MarkdownDescription: "Version of the API group",
										},
									},
									CustomType: Gvk1Type{
										ObjectType: types.ObjectType{
											AttrTypes: Gvk1Value{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IntentNameType{
								ObjectType: types.ObjectType{
									AttrTypes: IntentNameValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"output_crs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"gvk_2": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"group": schema.StringAttribute{
												Computed:            true,
												Description:         "Name of the API group",
												MarkdownDescription: "Name of the API group",
											},
											"kind": schema.StringAttribute{
												Computed:            true,
												Description:         "The Kind of the resource",
												MarkdownDescription: "The Kind of the resource",
											},
											"version": schema.StringAttribute{
												Computed:            true,
												Description:         "Version of the API group",
												MarkdownDescription: "Version of the API group",
											},
										},
										CustomType: Gvk2Type{
											ObjectType: types.ObjectType{
												AttrTypes: Gvk2Value{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"namespace": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: OutputCrsType{
									ObjectType: types.ObjectType{
										AttrTypes: OutputCrsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"script": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"execution_time": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ScriptType{
								ObjectType: types.ObjectType{
									AttrTypes: ScriptValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
					},
					CustomType: IntentsRunType{
						ObjectType: types.ObjectType{
							AttrTypes: IntentsRunValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "List of intents which ran as part of the transaction",
				MarkdownDescription: "List of intents which ran as part of the transaction",
			},
			"nodes_with_config_changes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"errors": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Resulting errors for the node",
							MarkdownDescription: "Resulting errors for the node",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the node",
							MarkdownDescription: "The name of the node",
						},
						"namespace": schema.StringAttribute{
							Computed:            true,
							Description:         "The namespace of the node",
							MarkdownDescription: "The namespace of the node",
						},
					},
					CustomType: NodesWithConfigChangesType{
						ObjectType: types.ObjectType{
							AttrTypes: NodesWithConfigChangesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "List of nodes with configuration changes from the transaction",
				MarkdownDescription: "List of nodes with configuration changes from the transaction",
			},
			"topology_supported": schema.BoolAttribute{
				Computed:            true,
				Description:         "Whether a topology representation of this transaction is supported",
				MarkdownDescription: "Whether a topology representation of this transaction is supported",
			},
			"transaction_id": schema.Int64Attribute{
				Required:            true,
				Description:         "The identifier for the transaction whose details are being requested",
				MarkdownDescription: "The identifier for the transaction whose details are being requested",
			},
			"wait_for_complete": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state.",
				MarkdownDescription: "Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state.",
			},
		},
	}
}

type TransactionExecutionResultModel struct {
	ChangedCrs             types.List   `tfsdk:"changed_crs"`
	ExecutionSummary       types.String `tfsdk:"execution_summary"`
	FailOnErrors           types.String `tfsdk:"fail_on_errors"`
	GeneralErrors          types.List   `tfsdk:"general_errors"`
	IntentsRun             types.List   `tfsdk:"intents_run"`
	NodesWithConfigChanges types.List   `tfsdk:"nodes_with_config_changes"`
	TopologySupported      types.Bool   `tfsdk:"topology_supported"`
	TransactionId          types.Int64  `tfsdk:"transaction_id"`
	WaitForComplete        types.String `tfsdk:"wait_for_complete"`
}

var _ basetypes.ObjectTypable = ChangedCrsType{}

type ChangedCrsType struct {
	basetypes.ObjectType
}

func (t ChangedCrsType) Equal(o attr.Type) bool {
	other, ok := o.(ChangedCrsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChangedCrsType) String() string {
	return "ChangedCrsType"
}

func (t ChangedCrsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gvkAttribute, ok := attributes["gvk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk is missing from object`)

		return nil, diags
	}

	gvkVal, ok := gvkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk expected to be basetypes.ObjectValue, was: %T`, gvkAttribute))
	}

	namesAttribute, ok := attributes["names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`names is missing from object`)

		return nil, diags
	}

	namesVal, ok := namesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`names expected to be basetypes.ListValue, was: %T`, namesAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChangedCrsValue{
		Gvk:       gvkVal,
		Names:     namesVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewChangedCrsValueNull() ChangedCrsValue {
	return ChangedCrsValue{
		state: attr.ValueStateNull,
	}
}

func NewChangedCrsValueUnknown() ChangedCrsValue {
	return ChangedCrsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChangedCrsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChangedCrsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChangedCrsValue Attribute Value",
				"While creating a ChangedCrsValue value, a missing attribute value was detected. "+
					"A ChangedCrsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChangedCrsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChangedCrsValue Attribute Type",
				"While creating a ChangedCrsValue value, an invalid attribute value was detected. "+
					"A ChangedCrsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChangedCrsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChangedCrsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChangedCrsValue Attribute Value",
				"While creating a ChangedCrsValue value, an extra attribute value was detected. "+
					"A ChangedCrsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChangedCrsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChangedCrsValueUnknown(), diags
	}

	gvkAttribute, ok := attributes["gvk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk is missing from object`)

		return NewChangedCrsValueUnknown(), diags
	}

	gvkVal, ok := gvkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk expected to be basetypes.ObjectValue, was: %T`, gvkAttribute))
	}

	namesAttribute, ok := attributes["names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`names is missing from object`)

		return NewChangedCrsValueUnknown(), diags
	}

	namesVal, ok := namesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`names expected to be basetypes.ListValue, was: %T`, namesAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewChangedCrsValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewChangedCrsValueUnknown(), diags
	}

	return ChangedCrsValue{
		Gvk:       gvkVal,
		Names:     namesVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewChangedCrsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChangedCrsValue {
	object, diags := NewChangedCrsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChangedCrsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChangedCrsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChangedCrsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChangedCrsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChangedCrsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChangedCrsValueMust(ChangedCrsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChangedCrsType) ValueType(ctx context.Context) attr.Value {
	return ChangedCrsValue{}
}

var _ basetypes.ObjectValuable = ChangedCrsValue{}

type ChangedCrsValue struct {
	Gvk       basetypes.ObjectValue `tfsdk:"gvk"`
	Names     basetypes.ListValue   `tfsdk:"names"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v ChangedCrsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["gvk"] = basetypes.ObjectType{
		AttrTypes: GvkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Gvk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gvk"] = val

		val, err = v.Names.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["names"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChangedCrsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChangedCrsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChangedCrsValue) String() string {
	return "ChangedCrsValue"
}

func (v ChangedCrsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gvk basetypes.ObjectValue

	if v.Gvk.IsNull() {
		gvk = types.ObjectNull(
			GvkValue{}.AttributeTypes(ctx),
		)
	}

	if v.Gvk.IsUnknown() {
		gvk = types.ObjectUnknown(
			GvkValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Gvk.IsNull() && !v.Gvk.IsUnknown() {
		gvk = types.ObjectValueMust(
			GvkValue{}.AttributeTypes(ctx),
			v.Gvk.Attributes(),
		)
	}

	var namesVal basetypes.ListValue
	switch {
	case v.Names.IsUnknown():
		namesVal = types.ListUnknown(types.StringType)
	case v.Names.IsNull():
		namesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		namesVal, d = types.ListValue(types.StringType, v.Names.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"gvk": basetypes.ObjectType{
				AttrTypes: GvkValue{}.AttributeTypes(ctx),
			},
			"names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"gvk": basetypes.ObjectType{
			AttrTypes: GvkValue{}.AttributeTypes(ctx),
		},
		"names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gvk":       gvk,
			"names":     namesVal,
			"namespace": v.Namespace,
		})

	return objVal, diags
}

func (v ChangedCrsValue) Equal(o attr.Value) bool {
	other, ok := o.(ChangedCrsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gvk.Equal(other.Gvk) {
		return false
	}

	if !v.Names.Equal(other.Names) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v ChangedCrsValue) Type(ctx context.Context) attr.Type {
	return ChangedCrsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChangedCrsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gvk": basetypes.ObjectType{
			AttrTypes: GvkValue{}.AttributeTypes(ctx),
		},
		"names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GvkType{}

type GvkType struct {
	basetypes.ObjectType
}

func (t GvkType) Equal(o attr.Type) bool {
	other, ok := o.(GvkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GvkType) String() string {
	return "GvkType"
}

func (t GvkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GvkValue{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvkValueNull() GvkValue {
	return GvkValue{
		state: attr.ValueStateNull,
	}
}

func NewGvkValueUnknown() GvkValue {
	return GvkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGvkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GvkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GvkValue Attribute Value",
				"While creating a GvkValue value, a missing attribute value was detected. "+
					"A GvkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GvkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GvkValue Attribute Type",
				"While creating a GvkValue value, an invalid attribute value was detected. "+
					"A GvkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GvkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GvkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GvkValue Attribute Value",
				"While creating a GvkValue value, an extra attribute value was detected. "+
					"A GvkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GvkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGvkValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewGvkValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewGvkValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewGvkValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewGvkValueUnknown(), diags
	}

	return GvkValue{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GvkValue {
	object, diags := NewGvkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGvkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GvkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGvkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGvkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGvkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGvkValueMust(GvkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GvkType) ValueType(ctx context.Context) attr.Value {
	return GvkValue{}
}

var _ basetypes.ObjectValuable = GvkValue{}

type GvkValue struct {
	Group   basetypes.StringValue `tfsdk:"group"`
	Kind    basetypes.StringValue `tfsdk:"kind"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v GvkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GvkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GvkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GvkValue) String() string {
	return "GvkValue"
}

func (v GvkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":   v.Group,
			"kind":    v.Kind,
			"version": v.Version,
		})

	return objVal, diags
}

func (v GvkValue) Equal(o attr.Value) bool {
	other, ok := o.(GvkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v GvkValue) Type(ctx context.Context) attr.Type {
	return GvkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GvkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IntentsRunType{}

type IntentsRunType struct {
	basetypes.ObjectType
}

func (t IntentsRunType) Equal(o attr.Type) bool {
	other, ok := o.(IntentsRunType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IntentsRunType) String() string {
	return "IntentsRunType"
}

func (t IntentsRunType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return nil, diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	intentNameAttribute, ok := attributes["intent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`intent_name is missing from object`)

		return nil, diags
	}

	intentNameVal, ok := intentNameAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`intent_name expected to be basetypes.ObjectValue, was: %T`, intentNameAttribute))
	}

	outputCrsAttribute, ok := attributes["output_crs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_crs is missing from object`)

		return nil, diags
	}

	outputCrsVal, ok := outputCrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_crs expected to be basetypes.ListValue, was: %T`, outputCrsAttribute))
	}

	scriptAttribute, ok := attributes["script"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`script is missing from object`)

		return nil, diags
	}

	scriptVal, ok := scriptAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`script expected to be basetypes.ObjectValue, was: %T`, scriptAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IntentsRunValue{
		Errors:     errorsVal,
		IntentName: intentNameVal,
		OutputCrs:  outputCrsVal,
		Script:     scriptVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIntentsRunValueNull() IntentsRunValue {
	return IntentsRunValue{
		state: attr.ValueStateNull,
	}
}

func NewIntentsRunValueUnknown() IntentsRunValue {
	return IntentsRunValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIntentsRunValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IntentsRunValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IntentsRunValue Attribute Value",
				"While creating a IntentsRunValue value, a missing attribute value was detected. "+
					"A IntentsRunValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntentsRunValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IntentsRunValue Attribute Type",
				"While creating a IntentsRunValue value, an invalid attribute value was detected. "+
					"A IntentsRunValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntentsRunValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IntentsRunValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IntentsRunValue Attribute Value",
				"While creating a IntentsRunValue value, an extra attribute value was detected. "+
					"A IntentsRunValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IntentsRunValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIntentsRunValueUnknown(), diags
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return NewIntentsRunValueUnknown(), diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	intentNameAttribute, ok := attributes["intent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`intent_name is missing from object`)

		return NewIntentsRunValueUnknown(), diags
	}

	intentNameVal, ok := intentNameAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`intent_name expected to be basetypes.ObjectValue, was: %T`, intentNameAttribute))
	}

	outputCrsAttribute, ok := attributes["output_crs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_crs is missing from object`)

		return NewIntentsRunValueUnknown(), diags
	}

	outputCrsVal, ok := outputCrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_crs expected to be basetypes.ListValue, was: %T`, outputCrsAttribute))
	}

	scriptAttribute, ok := attributes["script"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`script is missing from object`)

		return NewIntentsRunValueUnknown(), diags
	}

	scriptVal, ok := scriptAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`script expected to be basetypes.ObjectValue, was: %T`, scriptAttribute))
	}

	if diags.HasError() {
		return NewIntentsRunValueUnknown(), diags
	}

	return IntentsRunValue{
		Errors:     errorsVal,
		IntentName: intentNameVal,
		OutputCrs:  outputCrsVal,
		Script:     scriptVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIntentsRunValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IntentsRunValue {
	object, diags := NewIntentsRunValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIntentsRunValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IntentsRunType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIntentsRunValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIntentsRunValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIntentsRunValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIntentsRunValueMust(IntentsRunValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IntentsRunType) ValueType(ctx context.Context) attr.Value {
	return IntentsRunValue{}
}

var _ basetypes.ObjectValuable = IntentsRunValue{}

type IntentsRunValue struct {
	Errors     basetypes.ListValue   `tfsdk:"errors"`
	IntentName basetypes.ObjectValue `tfsdk:"intent_name"`
	OutputCrs  basetypes.ListValue   `tfsdk:"output_crs"`
	Script     basetypes.ObjectValue `tfsdk:"script"`
	state      attr.ValueState
}

func (v IntentsRunValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["errors"] = basetypes.ListType{
		ElemType: ErrorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["intent_name"] = basetypes.ObjectType{
		AttrTypes: IntentNameValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["output_crs"] = basetypes.ListType{
		ElemType: OutputCrsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["script"] = basetypes.ObjectType{
		AttrTypes: ScriptValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Errors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["errors"] = val

		val, err = v.IntentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["intent_name"] = val

		val, err = v.OutputCrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_crs"] = val

		val, err = v.Script.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["script"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IntentsRunValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IntentsRunValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IntentsRunValue) String() string {
	return "IntentsRunValue"
}

func (v IntentsRunValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	errors := types.ListValueMust(
		ErrorsType{
			basetypes.ObjectType{
				AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
			},
		},
		v.Errors.Elements(),
	)

	if v.Errors.IsNull() {
		errors = types.ListNull(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Errors.IsUnknown() {
		errors = types.ListUnknown(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var intentName basetypes.ObjectValue

	if v.IntentName.IsNull() {
		intentName = types.ObjectNull(
			IntentNameValue{}.AttributeTypes(ctx),
		)
	}

	if v.IntentName.IsUnknown() {
		intentName = types.ObjectUnknown(
			IntentNameValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IntentName.IsNull() && !v.IntentName.IsUnknown() {
		intentName = types.ObjectValueMust(
			IntentNameValue{}.AttributeTypes(ctx),
			v.IntentName.Attributes(),
		)
	}

	outputCrs := types.ListValueMust(
		OutputCrsType{
			basetypes.ObjectType{
				AttrTypes: OutputCrsValue{}.AttributeTypes(ctx),
			},
		},
		v.OutputCrs.Elements(),
	)

	if v.OutputCrs.IsNull() {
		outputCrs = types.ListNull(
			OutputCrsType{
				basetypes.ObjectType{
					AttrTypes: OutputCrsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OutputCrs.IsUnknown() {
		outputCrs = types.ListUnknown(
			OutputCrsType{
				basetypes.ObjectType{
					AttrTypes: OutputCrsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var script basetypes.ObjectValue

	if v.Script.IsNull() {
		script = types.ObjectNull(
			ScriptValue{}.AttributeTypes(ctx),
		)
	}

	if v.Script.IsUnknown() {
		script = types.ObjectUnknown(
			ScriptValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Script.IsNull() && !v.Script.IsUnknown() {
		script = types.ObjectValueMust(
			ScriptValue{}.AttributeTypes(ctx),
			v.Script.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"intent_name": basetypes.ObjectType{
			AttrTypes: IntentNameValue{}.AttributeTypes(ctx),
		},
		"output_crs": basetypes.ListType{
			ElemType: OutputCrsValue{}.Type(ctx),
		},
		"script": basetypes.ObjectType{
			AttrTypes: ScriptValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"errors":      errors,
			"intent_name": intentName,
			"output_crs":  outputCrs,
			"script":      script,
		})

	return objVal, diags
}

func (v IntentsRunValue) Equal(o attr.Value) bool {
	other, ok := o.(IntentsRunValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Errors.Equal(other.Errors) {
		return false
	}

	if !v.IntentName.Equal(other.IntentName) {
		return false
	}

	if !v.OutputCrs.Equal(other.OutputCrs) {
		return false
	}

	if !v.Script.Equal(other.Script) {
		return false
	}

	return true
}

func (v IntentsRunValue) Type(ctx context.Context) attr.Type {
	return IntentsRunType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IntentsRunValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"intent_name": basetypes.ObjectType{
			AttrTypes: IntentNameValue{}.AttributeTypes(ctx),
		},
		"output_crs": basetypes.ListType{
			ElemType: OutputCrsValue{}.Type(ctx),
		},
		"script": basetypes.ObjectType{
			AttrTypes: ScriptValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ErrorsType{}

type ErrorsType struct {
	basetypes.ObjectType
}

func (t ErrorsType) Equal(o attr.Type) bool {
	other, ok := o.(ErrorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ErrorsType) String() string {
	return "ErrorsType"
}

func (t ErrorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	rawErrorAttribute, ok := attributes["raw_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw_error is missing from object`)

		return nil, diags
	}

	rawErrorVal, ok := rawErrorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw_error expected to be basetypes.StringValue, was: %T`, rawErrorAttribute))
	}

	structuredErrorAttribute, ok := attributes["structured_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_error is missing from object`)

		return nil, diags
	}

	structuredErrorVal, ok := structuredErrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_error expected to be basetypes.ObjectValue, was: %T`, structuredErrorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ErrorsValue{
		RawError:        rawErrorVal,
		StructuredError: structuredErrorVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueNull() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateNull,
	}
}

func NewErrorsValueUnknown() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewErrorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ErrorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, a missing attribute value was detected. "+
					"A ErrorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ErrorsValue Attribute Type",
				"While creating a ErrorsValue value, an invalid attribute value was detected. "+
					"A ErrorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, an extra attribute value was detected. "+
					"A ErrorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ErrorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	rawErrorAttribute, ok := attributes["raw_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`raw_error is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	rawErrorVal, ok := rawErrorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`raw_error expected to be basetypes.StringValue, was: %T`, rawErrorAttribute))
	}

	structuredErrorAttribute, ok := attributes["structured_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_error is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	structuredErrorVal, ok := structuredErrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_error expected to be basetypes.ObjectValue, was: %T`, structuredErrorAttribute))
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	return ErrorsValue{
		RawError:        rawErrorVal,
		StructuredError: structuredErrorVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ErrorsValue {
	object, diags := NewErrorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewErrorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ErrorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewErrorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewErrorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewErrorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewErrorsValueMust(ErrorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ErrorsType) ValueType(ctx context.Context) attr.Value {
	return ErrorsValue{}
}

var _ basetypes.ObjectValuable = ErrorsValue{}

type ErrorsValue struct {
	RawError        basetypes.StringValue `tfsdk:"raw_error"`
	StructuredError basetypes.ObjectValue `tfsdk:"structured_error"`
	state           attr.ValueState
}

func (v ErrorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["raw_error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_error"] = basetypes.ObjectType{
		AttrTypes: StructuredErrorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.RawError.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["raw_error"] = val

		val, err = v.StructuredError.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_error"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ErrorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ErrorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ErrorsValue) String() string {
	return "ErrorsValue"
}

func (v ErrorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var structuredError basetypes.ObjectValue

	if v.StructuredError.IsNull() {
		structuredError = types.ObjectNull(
			StructuredErrorValue{}.AttributeTypes(ctx),
		)
	}

	if v.StructuredError.IsUnknown() {
		structuredError = types.ObjectUnknown(
			StructuredErrorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StructuredError.IsNull() && !v.StructuredError.IsUnknown() {
		structuredError = types.ObjectValueMust(
			StructuredErrorValue{}.AttributeTypes(ctx),
			v.StructuredError.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"raw_error": basetypes.StringType{},
		"structured_error": basetypes.ObjectType{
			AttrTypes: StructuredErrorValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"raw_error":        v.RawError,
			"structured_error": structuredError,
		})

	return objVal, diags
}

func (v ErrorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ErrorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RawError.Equal(other.RawError) {
		return false
	}

	if !v.StructuredError.Equal(other.StructuredError) {
		return false
	}

	return true
}

func (v ErrorsValue) Type(ctx context.Context) attr.Type {
	return ErrorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ErrorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"raw_error": basetypes.StringType{},
		"structured_error": basetypes.ObjectType{
			AttrTypes: StructuredErrorValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = StructuredErrorType{}

type StructuredErrorType struct {
	basetypes.ObjectType
}

func (t StructuredErrorType) Equal(o attr.Type) bool {
	other, ok := o.(StructuredErrorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StructuredErrorType) String() string {
	return "StructuredErrorType"
}

func (t StructuredErrorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	messageKeyAttribute, ok := attributes["message_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_key is missing from object`)

		return nil, diags
	}

	messageKeyVal, ok := messageKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_key expected to be basetypes.StringValue, was: %T`, messageKeyAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StructuredErrorValue{
		Message:    messageVal,
		MessageKey: messageKeyVal,
		Values:     valuesVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStructuredErrorValueNull() StructuredErrorValue {
	return StructuredErrorValue{
		state: attr.ValueStateNull,
	}
}

func NewStructuredErrorValueUnknown() StructuredErrorValue {
	return StructuredErrorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStructuredErrorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StructuredErrorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StructuredErrorValue Attribute Value",
				"While creating a StructuredErrorValue value, a missing attribute value was detected. "+
					"A StructuredErrorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StructuredErrorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StructuredErrorValue Attribute Type",
				"While creating a StructuredErrorValue value, an invalid attribute value was detected. "+
					"A StructuredErrorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StructuredErrorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StructuredErrorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StructuredErrorValue Attribute Value",
				"While creating a StructuredErrorValue value, an extra attribute value was detected. "+
					"A StructuredErrorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StructuredErrorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStructuredErrorValueUnknown(), diags
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewStructuredErrorValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	messageKeyAttribute, ok := attributes["message_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_key is missing from object`)

		return NewStructuredErrorValueUnknown(), diags
	}

	messageKeyVal, ok := messageKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_key expected to be basetypes.StringValue, was: %T`, messageKeyAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewStructuredErrorValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewStructuredErrorValueUnknown(), diags
	}

	return StructuredErrorValue{
		Message:    messageVal,
		MessageKey: messageKeyVal,
		Values:     valuesVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStructuredErrorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StructuredErrorValue {
	object, diags := NewStructuredErrorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStructuredErrorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StructuredErrorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStructuredErrorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStructuredErrorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStructuredErrorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStructuredErrorValueMust(StructuredErrorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StructuredErrorType) ValueType(ctx context.Context) attr.Value {
	return StructuredErrorValue{}
}

var _ basetypes.ObjectValuable = StructuredErrorValue{}

type StructuredErrorValue struct {
	Message    basetypes.StringValue `tfsdk:"message"`
	MessageKey basetypes.StringValue `tfsdk:"message_key"`
	Values     basetypes.MapValue    `tfsdk:"values"`
	state      attr.ValueState
}

func (v StructuredErrorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["message_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.MapType{
		ElemType: ValuesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		val, err = v.MessageKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message_key"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StructuredErrorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StructuredErrorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StructuredErrorValue) String() string {
	return "StructuredErrorValue"
}

func (v StructuredErrorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	values := types.MapValueMust(
		ValuesType{
			basetypes.ObjectType{
				AttrTypes: ValuesValue{}.AttributeTypes(ctx),
			},
		},
		v.Values.Elements(),
	)

	if v.Values.IsNull() {
		values = types.MapNull(
			ValuesType{
				basetypes.ObjectType{
					AttrTypes: ValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Values.IsUnknown() {
		values = types.MapUnknown(
			ValuesType{
				basetypes.ObjectType{
					AttrTypes: ValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"message":     basetypes.StringType{},
		"message_key": basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: ValuesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message":     v.Message,
			"message_key": v.MessageKey,
			"values":      values,
		})

	return objVal, diags
}

func (v StructuredErrorValue) Equal(o attr.Value) bool {
	other, ok := o.(StructuredErrorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	if !v.MessageKey.Equal(other.MessageKey) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v StructuredErrorValue) Type(ctx context.Context) attr.Type {
	return StructuredErrorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StructuredErrorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message":     basetypes.StringType{},
		"message_key": basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: ValuesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ValuesType{}

type ValuesType struct {
	basetypes.ObjectType
}

func (t ValuesType) Equal(o attr.Type) bool {
	other, ok := o.(ValuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ValuesType) String() string {
	return "ValuesType"
}

func (t ValuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return ValuesValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewValuesValueNull() ValuesValue {
	return ValuesValue{
		state: attr.ValueStateNull,
	}
}

func NewValuesValueUnknown() ValuesValue {
	return ValuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewValuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ValuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ValuesValue Attribute Value",
				"While creating a ValuesValue value, a missing attribute value was detected. "+
					"A ValuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ValuesValue Attribute Type",
				"While creating a ValuesValue value, an invalid attribute value was detected. "+
					"A ValuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ValuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ValuesValue Attribute Value",
				"While creating a ValuesValue value, an extra attribute value was detected. "+
					"A ValuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ValuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewValuesValueUnknown(), diags
	}

	if diags.HasError() {
		return NewValuesValueUnknown(), diags
	}

	return ValuesValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewValuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ValuesValue {
	object, diags := NewValuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewValuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ValuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewValuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewValuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewValuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewValuesValueMust(ValuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ValuesType) ValueType(ctx context.Context) attr.Value {
	return ValuesValue{}
}

var _ basetypes.ObjectValuable = ValuesValue{}

type ValuesValue struct {
	state attr.ValueState
}

func (v ValuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ValuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ValuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ValuesValue) String() string {
	return "ValuesValue"
}

func (v ValuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v ValuesValue) Equal(o attr.Value) bool {
	other, ok := o.(ValuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v ValuesValue) Type(ctx context.Context) attr.Type {
	return ValuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ValuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = IntentNameType{}

type IntentNameType struct {
	basetypes.ObjectType
}

func (t IntentNameType) Equal(o attr.Type) bool {
	other, ok := o.(IntentNameType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IntentNameType) String() string {
	return "IntentNameType"
}

func (t IntentNameType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gvk1Attribute, ok := attributes["gvk_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk_1 is missing from object`)

		return nil, diags
	}

	gvk1Val, ok := gvk1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk_1 expected to be basetypes.ObjectValue, was: %T`, gvk1Attribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IntentNameValue{
		Gvk1:      gvk1Val,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIntentNameValueNull() IntentNameValue {
	return IntentNameValue{
		state: attr.ValueStateNull,
	}
}

func NewIntentNameValueUnknown() IntentNameValue {
	return IntentNameValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIntentNameValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IntentNameValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IntentNameValue Attribute Value",
				"While creating a IntentNameValue value, a missing attribute value was detected. "+
					"A IntentNameValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntentNameValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IntentNameValue Attribute Type",
				"While creating a IntentNameValue value, an invalid attribute value was detected. "+
					"A IntentNameValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntentNameValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IntentNameValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IntentNameValue Attribute Value",
				"While creating a IntentNameValue value, an extra attribute value was detected. "+
					"A IntentNameValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IntentNameValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIntentNameValueUnknown(), diags
	}

	gvk1Attribute, ok := attributes["gvk_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk_1 is missing from object`)

		return NewIntentNameValueUnknown(), diags
	}

	gvk1Val, ok := gvk1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk_1 expected to be basetypes.ObjectValue, was: %T`, gvk1Attribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewIntentNameValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewIntentNameValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewIntentNameValueUnknown(), diags
	}

	return IntentNameValue{
		Gvk1:      gvk1Val,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIntentNameValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IntentNameValue {
	object, diags := NewIntentNameValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIntentNameValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IntentNameType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIntentNameValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIntentNameValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIntentNameValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIntentNameValueMust(IntentNameValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IntentNameType) ValueType(ctx context.Context) attr.Value {
	return IntentNameValue{}
}

var _ basetypes.ObjectValuable = IntentNameValue{}

type IntentNameValue struct {
	Gvk1      basetypes.ObjectValue `tfsdk:"gvk_1"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v IntentNameValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["gvk_1"] = basetypes.ObjectType{
		AttrTypes: Gvk1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Gvk1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gvk_1"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IntentNameValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IntentNameValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IntentNameValue) String() string {
	return "IntentNameValue"
}

func (v IntentNameValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gvk1 basetypes.ObjectValue

	if v.Gvk1.IsNull() {
		gvk1 = types.ObjectNull(
			Gvk1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Gvk1.IsUnknown() {
		gvk1 = types.ObjectUnknown(
			Gvk1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Gvk1.IsNull() && !v.Gvk1.IsUnknown() {
		gvk1 = types.ObjectValueMust(
			Gvk1Value{}.AttributeTypes(ctx),
			v.Gvk1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"gvk_1": basetypes.ObjectType{
			AttrTypes: Gvk1Value{}.AttributeTypes(ctx),
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gvk_1":     gvk1,
			"name":      v.Name,
			"namespace": v.Namespace,
		})

	return objVal, diags
}

func (v IntentNameValue) Equal(o attr.Value) bool {
	other, ok := o.(IntentNameValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gvk1.Equal(other.Gvk1) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v IntentNameValue) Type(ctx context.Context) attr.Type {
	return IntentNameType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IntentNameValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gvk_1": basetypes.ObjectType{
			AttrTypes: Gvk1Value{}.AttributeTypes(ctx),
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Gvk1Type{}

type Gvk1Type struct {
	basetypes.ObjectType
}

func (t Gvk1Type) Equal(o attr.Type) bool {
	other, ok := o.(Gvk1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Gvk1Type) String() string {
	return "Gvk1Type"
}

func (t Gvk1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Gvk1Value{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvk1ValueNull() Gvk1Value {
	return Gvk1Value{
		state: attr.ValueStateNull,
	}
}

func NewGvk1ValueUnknown() Gvk1Value {
	return Gvk1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewGvk1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Gvk1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Gvk1Value Attribute Value",
				"While creating a Gvk1Value value, a missing attribute value was detected. "+
					"A Gvk1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Gvk1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Gvk1Value Attribute Type",
				"While creating a Gvk1Value value, an invalid attribute value was detected. "+
					"A Gvk1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Gvk1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Gvk1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Gvk1Value Attribute Value",
				"While creating a Gvk1Value value, an extra attribute value was detected. "+
					"A Gvk1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Gvk1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGvk1ValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewGvk1ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewGvk1ValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewGvk1ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewGvk1ValueUnknown(), diags
	}

	return Gvk1Value{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvk1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Gvk1Value {
	object, diags := NewGvk1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGvk1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Gvk1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGvk1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGvk1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGvk1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGvk1ValueMust(Gvk1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Gvk1Type) ValueType(ctx context.Context) attr.Value {
	return Gvk1Value{}
}

var _ basetypes.ObjectValuable = Gvk1Value{}

type Gvk1Value struct {
	Group   basetypes.StringValue `tfsdk:"group"`
	Kind    basetypes.StringValue `tfsdk:"kind"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v Gvk1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Gvk1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Gvk1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Gvk1Value) String() string {
	return "Gvk1Value"
}

func (v Gvk1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":   v.Group,
			"kind":    v.Kind,
			"version": v.Version,
		})

	return objVal, diags
}

func (v Gvk1Value) Equal(o attr.Value) bool {
	other, ok := o.(Gvk1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Gvk1Value) Type(ctx context.Context) attr.Type {
	return Gvk1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Gvk1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OutputCrsType{}

type OutputCrsType struct {
	basetypes.ObjectType
}

func (t OutputCrsType) Equal(o attr.Type) bool {
	other, ok := o.(OutputCrsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OutputCrsType) String() string {
	return "OutputCrsType"
}

func (t OutputCrsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gvk2Attribute, ok := attributes["gvk_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk_2 is missing from object`)

		return nil, diags
	}

	gvk2Val, ok := gvk2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk_2 expected to be basetypes.ObjectValue, was: %T`, gvk2Attribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OutputCrsValue{
		Gvk2:      gvk2Val,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewOutputCrsValueNull() OutputCrsValue {
	return OutputCrsValue{
		state: attr.ValueStateNull,
	}
}

func NewOutputCrsValueUnknown() OutputCrsValue {
	return OutputCrsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOutputCrsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OutputCrsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OutputCrsValue Attribute Value",
				"While creating a OutputCrsValue value, a missing attribute value was detected. "+
					"A OutputCrsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutputCrsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OutputCrsValue Attribute Type",
				"While creating a OutputCrsValue value, an invalid attribute value was detected. "+
					"A OutputCrsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutputCrsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OutputCrsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OutputCrsValue Attribute Value",
				"While creating a OutputCrsValue value, an extra attribute value was detected. "+
					"A OutputCrsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OutputCrsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOutputCrsValueUnknown(), diags
	}

	gvk2Attribute, ok := attributes["gvk_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gvk_2 is missing from object`)

		return NewOutputCrsValueUnknown(), diags
	}

	gvk2Val, ok := gvk2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gvk_2 expected to be basetypes.ObjectValue, was: %T`, gvk2Attribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOutputCrsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewOutputCrsValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewOutputCrsValueUnknown(), diags
	}

	return OutputCrsValue{
		Gvk2:      gvk2Val,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewOutputCrsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OutputCrsValue {
	object, diags := NewOutputCrsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOutputCrsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OutputCrsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOutputCrsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOutputCrsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOutputCrsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOutputCrsValueMust(OutputCrsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OutputCrsType) ValueType(ctx context.Context) attr.Value {
	return OutputCrsValue{}
}

var _ basetypes.ObjectValuable = OutputCrsValue{}

type OutputCrsValue struct {
	Gvk2      basetypes.ObjectValue `tfsdk:"gvk_2"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v OutputCrsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["gvk_2"] = basetypes.ObjectType{
		AttrTypes: Gvk2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Gvk2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gvk_2"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OutputCrsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OutputCrsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OutputCrsValue) String() string {
	return "OutputCrsValue"
}

func (v OutputCrsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gvk2 basetypes.ObjectValue

	if v.Gvk2.IsNull() {
		gvk2 = types.ObjectNull(
			Gvk2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Gvk2.IsUnknown() {
		gvk2 = types.ObjectUnknown(
			Gvk2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Gvk2.IsNull() && !v.Gvk2.IsUnknown() {
		gvk2 = types.ObjectValueMust(
			Gvk2Value{}.AttributeTypes(ctx),
			v.Gvk2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"gvk_2": basetypes.ObjectType{
			AttrTypes: Gvk2Value{}.AttributeTypes(ctx),
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gvk_2":     gvk2,
			"name":      v.Name,
			"namespace": v.Namespace,
		})

	return objVal, diags
}

func (v OutputCrsValue) Equal(o attr.Value) bool {
	other, ok := o.(OutputCrsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gvk2.Equal(other.Gvk2) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v OutputCrsValue) Type(ctx context.Context) attr.Type {
	return OutputCrsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OutputCrsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gvk_2": basetypes.ObjectType{
			AttrTypes: Gvk2Value{}.AttributeTypes(ctx),
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Gvk2Type{}

type Gvk2Type struct {
	basetypes.ObjectType
}

func (t Gvk2Type) Equal(o attr.Type) bool {
	other, ok := o.(Gvk2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Gvk2Type) String() string {
	return "Gvk2Type"
}

func (t Gvk2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Gvk2Value{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvk2ValueNull() Gvk2Value {
	return Gvk2Value{
		state: attr.ValueStateNull,
	}
}

func NewGvk2ValueUnknown() Gvk2Value {
	return Gvk2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewGvk2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Gvk2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Gvk2Value Attribute Value",
				"While creating a Gvk2Value value, a missing attribute value was detected. "+
					"A Gvk2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Gvk2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Gvk2Value Attribute Type",
				"While creating a Gvk2Value value, an invalid attribute value was detected. "+
					"A Gvk2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Gvk2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Gvk2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Gvk2Value Attribute Value",
				"While creating a Gvk2Value value, an extra attribute value was detected. "+
					"A Gvk2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Gvk2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGvk2ValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewGvk2ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewGvk2ValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewGvk2ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewGvk2ValueUnknown(), diags
	}

	return Gvk2Value{
		Group:   groupVal,
		Kind:    kindVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGvk2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Gvk2Value {
	object, diags := NewGvk2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGvk2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Gvk2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGvk2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGvk2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGvk2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGvk2ValueMust(Gvk2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Gvk2Type) ValueType(ctx context.Context) attr.Value {
	return Gvk2Value{}
}

var _ basetypes.ObjectValuable = Gvk2Value{}

type Gvk2Value struct {
	Group   basetypes.StringValue `tfsdk:"group"`
	Kind    basetypes.StringValue `tfsdk:"kind"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v Gvk2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Gvk2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Gvk2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Gvk2Value) String() string {
	return "Gvk2Value"
}

func (v Gvk2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":   v.Group,
			"kind":    v.Kind,
			"version": v.Version,
		})

	return objVal, diags
}

func (v Gvk2Value) Equal(o attr.Value) bool {
	other, ok := o.(Gvk2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Gvk2Value) Type(ctx context.Context) attr.Type {
	return Gvk2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Gvk2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group":   basetypes.StringType{},
		"kind":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScriptType{}

type ScriptType struct {
	basetypes.ObjectType
}

func (t ScriptType) Equal(o attr.Type) bool {
	other, ok := o.(ScriptType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScriptType) String() string {
	return "ScriptType"
}

func (t ScriptType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	executionTimeAttribute, ok := attributes["execution_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`execution_time is missing from object`)

		return nil, diags
	}

	executionTimeVal, ok := executionTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`execution_time expected to be basetypes.Int64Value, was: %T`, executionTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScriptValue{
		ExecutionTime: executionTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewScriptValueNull() ScriptValue {
	return ScriptValue{
		state: attr.ValueStateNull,
	}
}

func NewScriptValueUnknown() ScriptValue {
	return ScriptValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScriptValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScriptValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScriptValue Attribute Value",
				"While creating a ScriptValue value, a missing attribute value was detected. "+
					"A ScriptValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScriptValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScriptValue Attribute Type",
				"While creating a ScriptValue value, an invalid attribute value was detected. "+
					"A ScriptValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScriptValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScriptValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScriptValue Attribute Value",
				"While creating a ScriptValue value, an extra attribute value was detected. "+
					"A ScriptValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScriptValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScriptValueUnknown(), diags
	}

	executionTimeAttribute, ok := attributes["execution_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`execution_time is missing from object`)

		return NewScriptValueUnknown(), diags
	}

	executionTimeVal, ok := executionTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`execution_time expected to be basetypes.Int64Value, was: %T`, executionTimeAttribute))
	}

	if diags.HasError() {
		return NewScriptValueUnknown(), diags
	}

	return ScriptValue{
		ExecutionTime: executionTimeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewScriptValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScriptValue {
	object, diags := NewScriptValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScriptValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScriptType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScriptValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScriptValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScriptValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScriptValueMust(ScriptValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScriptType) ValueType(ctx context.Context) attr.Value {
	return ScriptValue{}
}

var _ basetypes.ObjectValuable = ScriptValue{}

type ScriptValue struct {
	ExecutionTime basetypes.Int64Value `tfsdk:"execution_time"`
	state         attr.ValueState
}

func (v ScriptValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["execution_time"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ExecutionTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["execution_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScriptValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScriptValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScriptValue) String() string {
	return "ScriptValue"
}

func (v ScriptValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"execution_time": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"execution_time": v.ExecutionTime,
		})

	return objVal, diags
}

func (v ScriptValue) Equal(o attr.Value) bool {
	other, ok := o.(ScriptValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExecutionTime.Equal(other.ExecutionTime) {
		return false
	}

	return true
}

func (v ScriptValue) Type(ctx context.Context) attr.Type {
	return ScriptType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScriptValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"execution_time": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = NodesWithConfigChangesType{}

type NodesWithConfigChangesType struct {
	basetypes.ObjectType
}

func (t NodesWithConfigChangesType) Equal(o attr.Type) bool {
	other, ok := o.(NodesWithConfigChangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodesWithConfigChangesType) String() string {
	return "NodesWithConfigChangesType"
}

func (t NodesWithConfigChangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return nil, diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodesWithConfigChangesValue{
		Errors:    errorsVal,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNodesWithConfigChangesValueNull() NodesWithConfigChangesValue {
	return NodesWithConfigChangesValue{
		state: attr.ValueStateNull,
	}
}

func NewNodesWithConfigChangesValueUnknown() NodesWithConfigChangesValue {
	return NodesWithConfigChangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodesWithConfigChangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodesWithConfigChangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodesWithConfigChangesValue Attribute Value",
				"While creating a NodesWithConfigChangesValue value, a missing attribute value was detected. "+
					"A NodesWithConfigChangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesWithConfigChangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodesWithConfigChangesValue Attribute Type",
				"While creating a NodesWithConfigChangesValue value, an invalid attribute value was detected. "+
					"A NodesWithConfigChangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesWithConfigChangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodesWithConfigChangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodesWithConfigChangesValue Attribute Value",
				"While creating a NodesWithConfigChangesValue value, an extra attribute value was detected. "+
					"A NodesWithConfigChangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodesWithConfigChangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodesWithConfigChangesValueUnknown(), diags
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return NewNodesWithConfigChangesValueUnknown(), diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodesWithConfigChangesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewNodesWithConfigChangesValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewNodesWithConfigChangesValueUnknown(), diags
	}

	return NodesWithConfigChangesValue{
		Errors:    errorsVal,
		Name:      nameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNodesWithConfigChangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodesWithConfigChangesValue {
	object, diags := NewNodesWithConfigChangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodesWithConfigChangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodesWithConfigChangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodesWithConfigChangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodesWithConfigChangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodesWithConfigChangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodesWithConfigChangesValueMust(NodesWithConfigChangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodesWithConfigChangesType) ValueType(ctx context.Context) attr.Value {
	return NodesWithConfigChangesValue{}
}

var _ basetypes.ObjectValuable = NodesWithConfigChangesValue{}

type NodesWithConfigChangesValue struct {
	Errors    basetypes.ListValue   `tfsdk:"errors"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v NodesWithConfigChangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["errors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Errors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["errors"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodesWithConfigChangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodesWithConfigChangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodesWithConfigChangesValue) String() string {
	return "NodesWithConfigChangesValue"
}

func (v NodesWithConfigChangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var errorsVal basetypes.ListValue
	switch {
	case v.Errors.IsUnknown():
		errorsVal = types.ListUnknown(types.StringType)
	case v.Errors.IsNull():
		errorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		errorsVal, d = types.ListValue(types.StringType, v.Errors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"errors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"errors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"errors":    errorsVal,
			"name":      v.Name,
			"namespace": v.Namespace,
		})

	return objVal, diags
}

func (v NodesWithConfigChangesValue) Equal(o attr.Value) bool {
	other, ok := o.(NodesWithConfigChangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Errors.Equal(other.Errors) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v NodesWithConfigChangesValue) Type(ctx context.Context) attr.Type {
	return NodesWithConfigChangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodesWithConfigChangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"errors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}
