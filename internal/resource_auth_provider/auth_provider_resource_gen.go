// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_auth_provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func AuthProviderResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"auth": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bind_credential": schema.StringAttribute{
						Required:            true,
						Description:         "Credentials to use when binding to an LDAP provider",
						MarkdownDescription: "Credentials to use when binding to an LDAP provider",
					},
					"bind_dn": schema.StringAttribute{
						Required:            true,
						Description:         "DN to use when binding to an LDAP provider",
						MarkdownDescription: "DN to use when binding to an LDAP provider",
					},
				},
				CustomType: AuthType{
					ObjectType: types.ObjectType{
						AttrTypes: AuthValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "If present, bind to LDAP server with the given credentials.  Otherwise do not bind.",
				MarkdownDescription: "If present, bind to LDAP server with the given credentials.  Otherwise do not bind.",
			},
			"enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true, checking/syncing this LDAP provider is enabled.",
				MarkdownDescription: "If true, checking/syncing this LDAP provider is enabled.",
			},
			"group_support": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"filter": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using.",
						MarkdownDescription: "Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using.",
					},
					"group_ldapdn": schema.StringAttribute{
						Required:            true,
						Description:         "The LDAP DN where groups are found.",
						MarkdownDescription: "The LDAP DN where groups are found.",
					},
					"member_attribute": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The group attribute for a members.  Usually \"member\" or \"memberUid\".",
						MarkdownDescription: "The group attribute for a members.  Usually \"member\" or \"memberUid\".",
					},
					"member_of_attribute": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If retrievalStrategy is \"memberOf\", this is the LDAP user attribute for group memberships.",
						MarkdownDescription: "If retrievalStrategy is \"memberOf\", this is the LDAP user attribute for group memberships.",
					},
					"membership_attribute_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "How users are identified in a group member entry: either DN or UID.",
						MarkdownDescription: "How users are identified in a group member entry: either DN or UID.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DN",
								"UID",
							),
						},
					},
					"membership_user_attribute": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value.",
						MarkdownDescription: "Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value.",
					},
					"name_ldapattribute": schema.StringAttribute{
						Required:            true,
						Description:         "The LDAP group name attribute",
						MarkdownDescription: "The LDAP group name attribute",
					},
					"object_classes": schema.StringAttribute{
						Required:            true,
						Description:         "The LDAP object class or classes used for groups. If more than one, they must be comma-separated.",
						MarkdownDescription: "The LDAP object class or classes used for groups. If more than one, they must be comma-separated.",
					},
					"retrieval_strategy": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The strategy for retrieving groups.  Should be \"member\" to get group membership from the group, or \"memberOf\" to get group membership from the user.",
						MarkdownDescription: "The strategy for retrieving groups.  Should be \"member\" to get group membership from the group, or \"memberOf\" to get group membership from the user.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"member",
								"memberOf",
							),
						},
					},
				},
				CustomType: GroupSupportType{
					ObjectType: types.ObjectType{
						AttrTypes: GroupSupportValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.",
				MarkdownDescription: "Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.",
			},
			"id_attribute": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP.",
				MarkdownDescription: "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP.",
			},
			"import": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true, the LDAP information will be imported into the EDA (Keycloak) database.",
				MarkdownDescription: "If true, the LDAP information will be imported into the EDA (Keycloak) database.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name to give to the LDAP provider; must be unique.",
				MarkdownDescription: "The name to give to the LDAP provider; must be unique.",
			},
			"pagination": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true if the LDAP server supports pagination.",
				MarkdownDescription: "Set to true if the LDAP server supports pagination.",
			},
			"periodic_sync": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur.",
				MarkdownDescription: "If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur.",
			},
			"periodic_sync_secs": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If periodic sync is enabled, this is the period in seconds that synchronization will occur.",
				MarkdownDescription: "If periodic sync is enabled, this is the period in seconds that synchronization will occur.",
			},
			"rdn_ldapattribute": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required.",
				MarkdownDescription: "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required.",
			},
			"read_only": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.",
				MarkdownDescription: "If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.",
				Default:             booldefault.StaticBool(true),
			},
			"scope": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Must be \"One Level\" or \"Subtree\".  If \"One Level\", the search applies only for users in the DNs specified by User DNs. If \"Subtree\", the search applies to the whole subtree.",
				MarkdownDescription: "Must be \"One Level\" or \"Subtree\".  If \"One Level\", the search applies only for users in the DNs specified by User DNs. If \"Subtree\", the search applies to the whole subtree.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"One Level",
						"Subtree",
					),
				},
			},
			"timeout": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "LDAP connection timeout in milliseconds",
				MarkdownDescription: "LDAP connection timeout in milliseconds",
			},
			"tls": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true, encrypts the connection to LDAP using STARTTLS",
				MarkdownDescription: "If true, encrypts the connection to LDAP using STARTTLS",
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of provider.  Currently only \"ldap\" is supported.",
				MarkdownDescription: "The type of provider.  Currently only \"ldap\" is supported.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ldap",
					),
				},
			},
			"url": schema.StringAttribute{
				Required:            true,
				Description:         "Connection URL to your LDAP server",
				MarkdownDescription: "Connection URL to your LDAP server",
			},
			"user_dn": schema.StringAttribute{
				Required:            true,
				Description:         "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users.",
				MarkdownDescription: "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users.",
			},
			"user_object_classes": schema.StringAttribute{
				Required:            true,
				Description:         "All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson).",
				MarkdownDescription: "All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson).",
			},
			"user_search_filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
				MarkdownDescription: "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
			},
			"username_attribute": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'.",
				MarkdownDescription: "Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'.",
			},
			"uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The unique identifier given to the entry when it is created.",
				MarkdownDescription: "The unique identifier given to the entry when it is created.",
			},
			"vendor": schema.StringAttribute{
				Required:            true,
				Description:         "LDAP vendor (provider).",
				MarkdownDescription: "LDAP vendor (provider).",
			},
		},
	}
}

type AuthProviderModel struct {
	Auth              AuthValue         `tfsdk:"auth"`
	Enabled           types.Bool        `tfsdk:"enabled"`
	GroupSupport      GroupSupportValue `tfsdk:"group_support"`
	IdAttribute       types.String      `tfsdk:"id_attribute"`
	Import            types.Bool        `tfsdk:"import"`
	Name              types.String      `tfsdk:"name"`
	Pagination        types.Bool        `tfsdk:"pagination"`
	PeriodicSync      types.Bool        `tfsdk:"periodic_sync"`
	PeriodicSyncSecs  types.Int64       `tfsdk:"periodic_sync_secs"`
	RdnLdapattribute  types.String      `tfsdk:"rdn_ldapattribute"`
	ReadOnly          types.Bool        `tfsdk:"read_only"`
	Scope             types.String      `tfsdk:"scope"`
	Timeout           types.Int64       `tfsdk:"timeout"`
	Tls               types.Bool        `tfsdk:"tls"`
	Type              types.String      `tfsdk:"type"`
	Url               types.String      `tfsdk:"url"`
	UserDn            types.String      `tfsdk:"user_dn"`
	UserObjectClasses types.String      `tfsdk:"user_object_classes"`
	UserSearchFilter  types.String      `tfsdk:"user_search_filter"`
	UsernameAttribute types.String      `tfsdk:"username_attribute"`
	Uuid              types.String      `tfsdk:"uuid"`
	Vendor            types.String      `tfsdk:"vendor"`
}

var _ basetypes.ObjectTypable = AuthType{}

type AuthType struct {
	basetypes.ObjectType
}

func (t AuthType) Equal(o attr.Type) bool {
	other, ok := o.(AuthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthType) String() string {
	return "AuthType"
}

func (t AuthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bindCredentialAttribute, ok := attributes["bind_credential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_credential is missing from object`)

		return nil, diags
	}

	bindCredentialVal, ok := bindCredentialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_credential expected to be basetypes.StringValue, was: %T`, bindCredentialAttribute))
	}

	bindDnAttribute, ok := attributes["bind_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_dn is missing from object`)

		return nil, diags
	}

	bindDnVal, ok := bindDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_dn expected to be basetypes.StringValue, was: %T`, bindDnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthValue{
		BindCredential: bindCredentialVal,
		BindDn:         bindDnVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthValueNull() AuthValue {
	return AuthValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthValueUnknown() AuthValue {
	return AuthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthValue Attribute Value",
				"While creating a AuthValue value, a missing attribute value was detected. "+
					"A AuthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthValue Attribute Type",
				"While creating a AuthValue value, an invalid attribute value was detected. "+
					"A AuthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthValue Attribute Value",
				"While creating a AuthValue value, an extra attribute value was detected. "+
					"A AuthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	bindCredentialAttribute, ok := attributes["bind_credential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_credential is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	bindCredentialVal, ok := bindCredentialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_credential expected to be basetypes.StringValue, was: %T`, bindCredentialAttribute))
	}

	bindDnAttribute, ok := attributes["bind_dn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bind_dn is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	bindDnVal, ok := bindDnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bind_dn expected to be basetypes.StringValue, was: %T`, bindDnAttribute))
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	return AuthValue{
		BindCredential: bindCredentialVal,
		BindDn:         bindDnVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthValue {
	object, diags := NewAuthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthValueMust(AuthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthType) ValueType(ctx context.Context) attr.Value {
	return AuthValue{}
}

var _ basetypes.ObjectValuable = AuthValue{}

type AuthValue struct {
	BindCredential basetypes.StringValue `tfsdk:"bind_credential"`
	BindDn         basetypes.StringValue `tfsdk:"bind_dn"`
	state          attr.ValueState
}

func (v AuthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bind_credential"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bind_dn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.BindCredential.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bind_credential"] = val

		val, err = v.BindDn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bind_dn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthValue) String() string {
	return "AuthValue"
}

func (v AuthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bind_credential": basetypes.StringType{},
		"bind_dn":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bind_credential": v.BindCredential,
			"bind_dn":         v.BindDn,
		})

	return objVal, diags
}

func (v AuthValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BindCredential.Equal(other.BindCredential) {
		return false
	}

	if !v.BindDn.Equal(other.BindDn) {
		return false
	}

	return true
}

func (v AuthValue) Type(ctx context.Context) attr.Type {
	return AuthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bind_credential": basetypes.StringType{},
		"bind_dn":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GroupSupportType{}

type GroupSupportType struct {
	basetypes.ObjectType
}

func (t GroupSupportType) Equal(o attr.Type) bool {
	other, ok := o.(GroupSupportType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupSupportType) String() string {
	return "GroupSupportType"
}

func (t GroupSupportType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return nil, diags
	}

	filterVal, ok := filterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.StringValue, was: %T`, filterAttribute))
	}

	groupLdapdnAttribute, ok := attributes["group_ldapdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_ldapdn is missing from object`)

		return nil, diags
	}

	groupLdapdnVal, ok := groupLdapdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_ldapdn expected to be basetypes.StringValue, was: %T`, groupLdapdnAttribute))
	}

	memberAttributeAttribute, ok := attributes["member_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_attribute is missing from object`)

		return nil, diags
	}

	memberAttributeVal, ok := memberAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_attribute expected to be basetypes.StringValue, was: %T`, memberAttributeAttribute))
	}

	memberOfAttributeAttribute, ok := attributes["member_of_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_of_attribute is missing from object`)

		return nil, diags
	}

	memberOfAttributeVal, ok := memberOfAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_of_attribute expected to be basetypes.StringValue, was: %T`, memberOfAttributeAttribute))
	}

	membershipAttributeTypeAttribute, ok := attributes["membership_attribute_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_attribute_type is missing from object`)

		return nil, diags
	}

	membershipAttributeTypeVal, ok := membershipAttributeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_attribute_type expected to be basetypes.StringValue, was: %T`, membershipAttributeTypeAttribute))
	}

	membershipUserAttributeAttribute, ok := attributes["membership_user_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_user_attribute is missing from object`)

		return nil, diags
	}

	membershipUserAttributeVal, ok := membershipUserAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_user_attribute expected to be basetypes.StringValue, was: %T`, membershipUserAttributeAttribute))
	}

	nameLdapattributeAttribute, ok := attributes["name_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_ldapattribute is missing from object`)

		return nil, diags
	}

	nameLdapattributeVal, ok := nameLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_ldapattribute expected to be basetypes.StringValue, was: %T`, nameLdapattributeAttribute))
	}

	objectClassesAttribute, ok := attributes["object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_classes is missing from object`)

		return nil, diags
	}

	objectClassesVal, ok := objectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_classes expected to be basetypes.StringValue, was: %T`, objectClassesAttribute))
	}

	retrievalStrategyAttribute, ok := attributes["retrieval_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retrieval_strategy is missing from object`)

		return nil, diags
	}

	retrievalStrategyVal, ok := retrievalStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retrieval_strategy expected to be basetypes.StringValue, was: %T`, retrievalStrategyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupSupportValue{
		Filter:                  filterVal,
		GroupLdapdn:             groupLdapdnVal,
		MemberAttribute:         memberAttributeVal,
		MemberOfAttribute:       memberOfAttributeVal,
		MembershipAttributeType: membershipAttributeTypeVal,
		MembershipUserAttribute: membershipUserAttributeVal,
		NameLdapattribute:       nameLdapattributeVal,
		ObjectClasses:           objectClassesVal,
		RetrievalStrategy:       retrievalStrategyVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewGroupSupportValueNull() GroupSupportValue {
	return GroupSupportValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupSupportValueUnknown() GroupSupportValue {
	return GroupSupportValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupSupportValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupSupportValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupSupportValue Attribute Value",
				"While creating a GroupSupportValue value, a missing attribute value was detected. "+
					"A GroupSupportValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupSupportValue Attribute Type",
				"While creating a GroupSupportValue value, an invalid attribute value was detected. "+
					"A GroupSupportValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupSupportValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupSupportValue Attribute Value",
				"While creating a GroupSupportValue value, an extra attribute value was detected. "+
					"A GroupSupportValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupSupportValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupSupportValueUnknown(), diags
	}

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	filterVal, ok := filterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.StringValue, was: %T`, filterAttribute))
	}

	groupLdapdnAttribute, ok := attributes["group_ldapdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_ldapdn is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	groupLdapdnVal, ok := groupLdapdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_ldapdn expected to be basetypes.StringValue, was: %T`, groupLdapdnAttribute))
	}

	memberAttributeAttribute, ok := attributes["member_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	memberAttributeVal, ok := memberAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_attribute expected to be basetypes.StringValue, was: %T`, memberAttributeAttribute))
	}

	memberOfAttributeAttribute, ok := attributes["member_of_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`member_of_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	memberOfAttributeVal, ok := memberOfAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`member_of_attribute expected to be basetypes.StringValue, was: %T`, memberOfAttributeAttribute))
	}

	membershipAttributeTypeAttribute, ok := attributes["membership_attribute_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_attribute_type is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	membershipAttributeTypeVal, ok := membershipAttributeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_attribute_type expected to be basetypes.StringValue, was: %T`, membershipAttributeTypeAttribute))
	}

	membershipUserAttributeAttribute, ok := attributes["membership_user_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`membership_user_attribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	membershipUserAttributeVal, ok := membershipUserAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`membership_user_attribute expected to be basetypes.StringValue, was: %T`, membershipUserAttributeAttribute))
	}

	nameLdapattributeAttribute, ok := attributes["name_ldapattribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_ldapattribute is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	nameLdapattributeVal, ok := nameLdapattributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_ldapattribute expected to be basetypes.StringValue, was: %T`, nameLdapattributeAttribute))
	}

	objectClassesAttribute, ok := attributes["object_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_classes is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	objectClassesVal, ok := objectClassesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_classes expected to be basetypes.StringValue, was: %T`, objectClassesAttribute))
	}

	retrievalStrategyAttribute, ok := attributes["retrieval_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retrieval_strategy is missing from object`)

		return NewGroupSupportValueUnknown(), diags
	}

	retrievalStrategyVal, ok := retrievalStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retrieval_strategy expected to be basetypes.StringValue, was: %T`, retrievalStrategyAttribute))
	}

	if diags.HasError() {
		return NewGroupSupportValueUnknown(), diags
	}

	return GroupSupportValue{
		Filter:                  filterVal,
		GroupLdapdn:             groupLdapdnVal,
		MemberAttribute:         memberAttributeVal,
		MemberOfAttribute:       memberOfAttributeVal,
		MembershipAttributeType: membershipAttributeTypeVal,
		MembershipUserAttribute: membershipUserAttributeVal,
		NameLdapattribute:       nameLdapattributeVal,
		ObjectClasses:           objectClassesVal,
		RetrievalStrategy:       retrievalStrategyVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewGroupSupportValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupSupportValue {
	object, diags := NewGroupSupportValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupSupportValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupSupportType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupSupportValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupSupportValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupSupportValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupSupportValueMust(GroupSupportValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupSupportType) ValueType(ctx context.Context) attr.Value {
	return GroupSupportValue{}
}

var _ basetypes.ObjectValuable = GroupSupportValue{}

type GroupSupportValue struct {
	Filter                  basetypes.StringValue `tfsdk:"filter"`
	GroupLdapdn             basetypes.StringValue `tfsdk:"group_ldapdn"`
	MemberAttribute         basetypes.StringValue `tfsdk:"member_attribute"`
	MemberOfAttribute       basetypes.StringValue `tfsdk:"member_of_attribute"`
	MembershipAttributeType basetypes.StringValue `tfsdk:"membership_attribute_type"`
	MembershipUserAttribute basetypes.StringValue `tfsdk:"membership_user_attribute"`
	NameLdapattribute       basetypes.StringValue `tfsdk:"name_ldapattribute"`
	ObjectClasses           basetypes.StringValue `tfsdk:"object_classes"`
	RetrievalStrategy       basetypes.StringValue `tfsdk:"retrieval_strategy"`
	state                   attr.ValueState
}

func (v GroupSupportValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["filter"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_ldapdn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["member_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["member_of_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["membership_attribute_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["membership_user_attribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_ldapattribute"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["object_classes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["retrieval_strategy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Filter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filter"] = val

		val, err = v.GroupLdapdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_ldapdn"] = val

		val, err = v.MemberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["member_attribute"] = val

		val, err = v.MemberOfAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["member_of_attribute"] = val

		val, err = v.MembershipAttributeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["membership_attribute_type"] = val

		val, err = v.MembershipUserAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["membership_user_attribute"] = val

		val, err = v.NameLdapattribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_ldapattribute"] = val

		val, err = v.ObjectClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_classes"] = val

		val, err = v.RetrievalStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retrieval_strategy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupSupportValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupSupportValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupSupportValue) String() string {
	return "GroupSupportValue"
}

func (v GroupSupportValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"filter":                    basetypes.StringType{},
		"group_ldapdn":              basetypes.StringType{},
		"member_attribute":          basetypes.StringType{},
		"member_of_attribute":       basetypes.StringType{},
		"membership_attribute_type": basetypes.StringType{},
		"membership_user_attribute": basetypes.StringType{},
		"name_ldapattribute":        basetypes.StringType{},
		"object_classes":            basetypes.StringType{},
		"retrieval_strategy":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filter":                    v.Filter,
			"group_ldapdn":              v.GroupLdapdn,
			"member_attribute":          v.MemberAttribute,
			"member_of_attribute":       v.MemberOfAttribute,
			"membership_attribute_type": v.MembershipAttributeType,
			"membership_user_attribute": v.MembershipUserAttribute,
			"name_ldapattribute":        v.NameLdapattribute,
			"object_classes":            v.ObjectClasses,
			"retrieval_strategy":        v.RetrievalStrategy,
		})

	return objVal, diags
}

func (v GroupSupportValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupSupportValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filter.Equal(other.Filter) {
		return false
	}

	if !v.GroupLdapdn.Equal(other.GroupLdapdn) {
		return false
	}

	if !v.MemberAttribute.Equal(other.MemberAttribute) {
		return false
	}

	if !v.MemberOfAttribute.Equal(other.MemberOfAttribute) {
		return false
	}

	if !v.MembershipAttributeType.Equal(other.MembershipAttributeType) {
		return false
	}

	if !v.MembershipUserAttribute.Equal(other.MembershipUserAttribute) {
		return false
	}

	if !v.NameLdapattribute.Equal(other.NameLdapattribute) {
		return false
	}

	if !v.ObjectClasses.Equal(other.ObjectClasses) {
		return false
	}

	if !v.RetrievalStrategy.Equal(other.RetrievalStrategy) {
		return false
	}

	return true
}

func (v GroupSupportValue) Type(ctx context.Context) attr.Type {
	return GroupSupportType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupSupportValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filter":                    basetypes.StringType{},
		"group_ldapdn":              basetypes.StringType{},
		"member_attribute":          basetypes.StringType{},
		"member_of_attribute":       basetypes.StringType{},
		"membership_attribute_type": basetypes.StringType{},
		"membership_user_attribute": basetypes.StringType{},
		"name_ldapattribute":        basetypes.StringType{},
		"object_classes":            basetypes.StringType{},
		"retrieval_strategy":        basetypes.StringType{},
	}
}
