// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_overlays

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OverlaysDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"overlays": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"endpoint_attr_queries": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"attributes": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"ui_description": schema.StringAttribute{
													Computed: true,
												},
												"ui_description_key": schema.StringAttribute{
													Computed: true,
												},
												"ui_name": schema.StringAttribute{
													Computed: true,
												},
												"ui_name_key": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: AttributesType{
												ObjectType: types.ObjectType{
													AttrTypes: AttributesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"query": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: EndpointAttrQueriesType{
									ObjectType: types.ObjectType{
										AttrTypes: EndpointAttrQueriesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"endpoint_state": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"color": schema.StringAttribute{
										Computed: true,
									},
									"ui_description": schema.StringAttribute{
										Computed: true,
									},
									"ui_description_key": schema.StringAttribute{
										Computed: true,
									},
									"ui_name": schema.StringAttribute{
										Computed: true,
									},
									"ui_name_key": schema.StringAttribute{
										Computed: true,
									},
									"value": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: EndpointStateType{
									ObjectType: types.ObjectType{
										AttrTypes: EndpointStateValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"endpoint_state_heading": schema.StringAttribute{
							Computed: true,
						},
						"endpoint_state_heading_key": schema.StringAttribute{
							Computed: true,
						},
						"group": schema.StringAttribute{
							Computed: true,
						},
						"link_attr_queries": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"attributes_1": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"ui_description": schema.StringAttribute{
													Computed: true,
												},
												"ui_description_key": schema.StringAttribute{
													Computed: true,
												},
												"ui_name": schema.StringAttribute{
													Computed: true,
												},
												"ui_name_key": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: Attributes1Type{
												ObjectType: types.ObjectType{
													AttrTypes: Attributes1Value{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"query": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: LinkAttrQueriesType{
									ObjectType: types.ObjectType{
										AttrTypes: LinkAttrQueriesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"link_state": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"color": schema.StringAttribute{
										Computed: true,
									},
									"ui_description": schema.StringAttribute{
										Computed: true,
									},
									"ui_description_key": schema.StringAttribute{
										Computed: true,
									},
									"ui_name": schema.StringAttribute{
										Computed: true,
									},
									"ui_name_key": schema.StringAttribute{
										Computed: true,
									},
									"value": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: LinkStateType{
									ObjectType: types.ObjectType{
										AttrTypes: LinkStateValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"link_state_heading": schema.StringAttribute{
							Computed: true,
						},
						"link_state_heading_key": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"node_attr_queries": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"attributes_2": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"ui_description": schema.StringAttribute{
													Computed: true,
												},
												"ui_description_key": schema.StringAttribute{
													Computed: true,
												},
												"ui_name": schema.StringAttribute{
													Computed: true,
												},
												"ui_name_key": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: Attributes2Type{
												ObjectType: types.ObjectType{
													AttrTypes: Attributes2Value{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"query": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: NodeAttrQueriesType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeAttrQueriesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"node_badge": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"badge_name": schema.StringAttribute{
										Computed: true,
									},
									"badge_path": schema.StringAttribute{
										Computed: true,
									},
									"color": schema.StringAttribute{
										Computed: true,
									},
									"ui_description": schema.StringAttribute{
										Computed: true,
									},
									"ui_description_key": schema.StringAttribute{
										Computed: true,
									},
									"ui_name": schema.StringAttribute{
										Computed: true,
									},
									"ui_name_key": schema.StringAttribute{
										Computed: true,
									},
									"value": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: NodeBadgeType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeBadgeValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"node_state": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"color": schema.StringAttribute{
										Computed: true,
									},
									"ui_description": schema.StringAttribute{
										Computed: true,
									},
									"ui_description_key": schema.StringAttribute{
										Computed: true,
									},
									"ui_name": schema.StringAttribute{
										Computed: true,
									},
									"ui_name_key": schema.StringAttribute{
										Computed: true,
									},
									"value": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: NodeStateType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeStateValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"node_state_heading": schema.StringAttribute{
							Computed: true,
						},
						"node_state_heading_key": schema.StringAttribute{
							Computed: true,
						},
						"ui_description": schema.StringAttribute{
							Computed: true,
						},
						"ui_description_key": schema.StringAttribute{
							Computed: true,
						},
						"ui_name": schema.StringAttribute{
							Computed: true,
						},
						"ui_name_key": schema.StringAttribute{
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: OverlaysType{
						ObjectType: types.ObjectType{
							AttrTypes: OverlaysValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"topology_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the topology on which to list overlays",
				MarkdownDescription: "The name of the topology on which to list overlays",
			},
		},
	}
}

type OverlaysModel struct {
	Overlays     types.Set    `tfsdk:"overlays"`
	TopologyName types.String `tfsdk:"topology_name"`
}

var _ basetypes.ObjectTypable = OverlaysType{}

type OverlaysType struct {
	basetypes.ObjectType
}

func (t OverlaysType) Equal(o attr.Type) bool {
	other, ok := o.(OverlaysType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverlaysType) String() string {
	return "OverlaysType"
}

func (t OverlaysType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endpointAttrQueriesAttribute, ok := attributes["endpoint_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_attr_queries is missing from object`)

		return nil, diags
	}

	endpointAttrQueriesVal, ok := endpointAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_attr_queries expected to be basetypes.ListValue, was: %T`, endpointAttrQueriesAttribute))
	}

	endpointStateAttribute, ok := attributes["endpoint_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state is missing from object`)

		return nil, diags
	}

	endpointStateVal, ok := endpointStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state expected to be basetypes.ListValue, was: %T`, endpointStateAttribute))
	}

	endpointStateHeadingAttribute, ok := attributes["endpoint_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state_heading is missing from object`)

		return nil, diags
	}

	endpointStateHeadingVal, ok := endpointStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state_heading expected to be basetypes.StringValue, was: %T`, endpointStateHeadingAttribute))
	}

	endpointStateHeadingKeyAttribute, ok := attributes["endpoint_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state_heading_key is missing from object`)

		return nil, diags
	}

	endpointStateHeadingKeyVal, ok := endpointStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state_heading_key expected to be basetypes.StringValue, was: %T`, endpointStateHeadingKeyAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	linkAttrQueriesAttribute, ok := attributes["link_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_attr_queries is missing from object`)

		return nil, diags
	}

	linkAttrQueriesVal, ok := linkAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_attr_queries expected to be basetypes.ListValue, was: %T`, linkAttrQueriesAttribute))
	}

	linkStateAttribute, ok := attributes["link_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state is missing from object`)

		return nil, diags
	}

	linkStateVal, ok := linkStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state expected to be basetypes.ListValue, was: %T`, linkStateAttribute))
	}

	linkStateHeadingAttribute, ok := attributes["link_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state_heading is missing from object`)

		return nil, diags
	}

	linkStateHeadingVal, ok := linkStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state_heading expected to be basetypes.StringValue, was: %T`, linkStateHeadingAttribute))
	}

	linkStateHeadingKeyAttribute, ok := attributes["link_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state_heading_key is missing from object`)

		return nil, diags
	}

	linkStateHeadingKeyVal, ok := linkStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state_heading_key expected to be basetypes.StringValue, was: %T`, linkStateHeadingKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeAttrQueriesAttribute, ok := attributes["node_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_attr_queries is missing from object`)

		return nil, diags
	}

	nodeAttrQueriesVal, ok := nodeAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_attr_queries expected to be basetypes.ListValue, was: %T`, nodeAttrQueriesAttribute))
	}

	nodeBadgeAttribute, ok := attributes["node_badge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_badge is missing from object`)

		return nil, diags
	}

	nodeBadgeVal, ok := nodeBadgeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_badge expected to be basetypes.ListValue, was: %T`, nodeBadgeAttribute))
	}

	nodeStateAttribute, ok := attributes["node_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state is missing from object`)

		return nil, diags
	}

	nodeStateVal, ok := nodeStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state expected to be basetypes.ListValue, was: %T`, nodeStateAttribute))
	}

	nodeStateHeadingAttribute, ok := attributes["node_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state_heading is missing from object`)

		return nil, diags
	}

	nodeStateHeadingVal, ok := nodeStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state_heading expected to be basetypes.StringValue, was: %T`, nodeStateHeadingAttribute))
	}

	nodeStateHeadingKeyAttribute, ok := attributes["node_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state_heading_key is missing from object`)

		return nil, diags
	}

	nodeStateHeadingKeyVal, ok := nodeStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state_heading_key expected to be basetypes.StringValue, was: %T`, nodeStateHeadingKeyAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverlaysValue{
		EndpointAttrQueries:     endpointAttrQueriesVal,
		EndpointState:           endpointStateVal,
		EndpointStateHeading:    endpointStateHeadingVal,
		EndpointStateHeadingKey: endpointStateHeadingKeyVal,
		Group:                   groupVal,
		LinkAttrQueries:         linkAttrQueriesVal,
		LinkState:               linkStateVal,
		LinkStateHeading:        linkStateHeadingVal,
		LinkStateHeadingKey:     linkStateHeadingKeyVal,
		Name:                    nameVal,
		NodeAttrQueries:         nodeAttrQueriesVal,
		NodeBadge:               nodeBadgeVal,
		NodeState:               nodeStateVal,
		NodeStateHeading:        nodeStateHeadingVal,
		NodeStateHeadingKey:     nodeStateHeadingKeyVal,
		UiDescription:           uiDescriptionVal,
		UiDescriptionKey:        uiDescriptionKeyVal,
		UiName:                  uiNameVal,
		UiNameKey:               uiNameKeyVal,
		Version:                 versionVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewOverlaysValueNull() OverlaysValue {
	return OverlaysValue{
		state: attr.ValueStateNull,
	}
}

func NewOverlaysValueUnknown() OverlaysValue {
	return OverlaysValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverlaysValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverlaysValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverlaysValue Attribute Value",
				"While creating a OverlaysValue value, a missing attribute value was detected. "+
					"A OverlaysValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlaysValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverlaysValue Attribute Type",
				"While creating a OverlaysValue value, an invalid attribute value was detected. "+
					"A OverlaysValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlaysValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverlaysValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverlaysValue Attribute Value",
				"While creating a OverlaysValue value, an extra attribute value was detected. "+
					"A OverlaysValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverlaysValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverlaysValueUnknown(), diags
	}

	endpointAttrQueriesAttribute, ok := attributes["endpoint_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_attr_queries is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	endpointAttrQueriesVal, ok := endpointAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_attr_queries expected to be basetypes.ListValue, was: %T`, endpointAttrQueriesAttribute))
	}

	endpointStateAttribute, ok := attributes["endpoint_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	endpointStateVal, ok := endpointStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state expected to be basetypes.ListValue, was: %T`, endpointStateAttribute))
	}

	endpointStateHeadingAttribute, ok := attributes["endpoint_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state_heading is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	endpointStateHeadingVal, ok := endpointStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state_heading expected to be basetypes.StringValue, was: %T`, endpointStateHeadingAttribute))
	}

	endpointStateHeadingKeyAttribute, ok := attributes["endpoint_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_state_heading_key is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	endpointStateHeadingKeyVal, ok := endpointStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_state_heading_key expected to be basetypes.StringValue, was: %T`, endpointStateHeadingKeyAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	linkAttrQueriesAttribute, ok := attributes["link_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_attr_queries is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	linkAttrQueriesVal, ok := linkAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_attr_queries expected to be basetypes.ListValue, was: %T`, linkAttrQueriesAttribute))
	}

	linkStateAttribute, ok := attributes["link_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	linkStateVal, ok := linkStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state expected to be basetypes.ListValue, was: %T`, linkStateAttribute))
	}

	linkStateHeadingAttribute, ok := attributes["link_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state_heading is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	linkStateHeadingVal, ok := linkStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state_heading expected to be basetypes.StringValue, was: %T`, linkStateHeadingAttribute))
	}

	linkStateHeadingKeyAttribute, ok := attributes["link_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_state_heading_key is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	linkStateHeadingKeyVal, ok := linkStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_state_heading_key expected to be basetypes.StringValue, was: %T`, linkStateHeadingKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeAttrQueriesAttribute, ok := attributes["node_attr_queries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_attr_queries is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nodeAttrQueriesVal, ok := nodeAttrQueriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_attr_queries expected to be basetypes.ListValue, was: %T`, nodeAttrQueriesAttribute))
	}

	nodeBadgeAttribute, ok := attributes["node_badge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_badge is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nodeBadgeVal, ok := nodeBadgeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_badge expected to be basetypes.ListValue, was: %T`, nodeBadgeAttribute))
	}

	nodeStateAttribute, ok := attributes["node_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nodeStateVal, ok := nodeStateAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state expected to be basetypes.ListValue, was: %T`, nodeStateAttribute))
	}

	nodeStateHeadingAttribute, ok := attributes["node_state_heading"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state_heading is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nodeStateHeadingVal, ok := nodeStateHeadingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state_heading expected to be basetypes.StringValue, was: %T`, nodeStateHeadingAttribute))
	}

	nodeStateHeadingKeyAttribute, ok := attributes["node_state_heading_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_state_heading_key is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	nodeStateHeadingKeyVal, ok := nodeStateHeadingKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_state_heading_key expected to be basetypes.StringValue, was: %T`, nodeStateHeadingKeyAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewOverlaysValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewOverlaysValueUnknown(), diags
	}

	return OverlaysValue{
		EndpointAttrQueries:     endpointAttrQueriesVal,
		EndpointState:           endpointStateVal,
		EndpointStateHeading:    endpointStateHeadingVal,
		EndpointStateHeadingKey: endpointStateHeadingKeyVal,
		Group:                   groupVal,
		LinkAttrQueries:         linkAttrQueriesVal,
		LinkState:               linkStateVal,
		LinkStateHeading:        linkStateHeadingVal,
		LinkStateHeadingKey:     linkStateHeadingKeyVal,
		Name:                    nameVal,
		NodeAttrQueries:         nodeAttrQueriesVal,
		NodeBadge:               nodeBadgeVal,
		NodeState:               nodeStateVal,
		NodeStateHeading:        nodeStateHeadingVal,
		NodeStateHeadingKey:     nodeStateHeadingKeyVal,
		UiDescription:           uiDescriptionVal,
		UiDescriptionKey:        uiDescriptionKeyVal,
		UiName:                  uiNameVal,
		UiNameKey:               uiNameKeyVal,
		Version:                 versionVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewOverlaysValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverlaysValue {
	object, diags := NewOverlaysValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverlaysValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverlaysType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverlaysValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverlaysValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverlaysValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverlaysValueMust(OverlaysValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverlaysType) ValueType(ctx context.Context) attr.Value {
	return OverlaysValue{}
}

var _ basetypes.ObjectValuable = OverlaysValue{}

type OverlaysValue struct {
	EndpointAttrQueries     basetypes.ListValue   `tfsdk:"endpoint_attr_queries"`
	EndpointState           basetypes.ListValue   `tfsdk:"endpoint_state"`
	EndpointStateHeading    basetypes.StringValue `tfsdk:"endpoint_state_heading"`
	EndpointStateHeadingKey basetypes.StringValue `tfsdk:"endpoint_state_heading_key"`
	Group                   basetypes.StringValue `tfsdk:"group"`
	LinkAttrQueries         basetypes.ListValue   `tfsdk:"link_attr_queries"`
	LinkState               basetypes.ListValue   `tfsdk:"link_state"`
	LinkStateHeading        basetypes.StringValue `tfsdk:"link_state_heading"`
	LinkStateHeadingKey     basetypes.StringValue `tfsdk:"link_state_heading_key"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	NodeAttrQueries         basetypes.ListValue   `tfsdk:"node_attr_queries"`
	NodeBadge               basetypes.ListValue   `tfsdk:"node_badge"`
	NodeState               basetypes.ListValue   `tfsdk:"node_state"`
	NodeStateHeading        basetypes.StringValue `tfsdk:"node_state_heading"`
	NodeStateHeadingKey     basetypes.StringValue `tfsdk:"node_state_heading_key"`
	UiDescription           basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey        basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName                  basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey               basetypes.StringValue `tfsdk:"ui_name_key"`
	Version                 basetypes.StringValue `tfsdk:"version"`
	state                   attr.ValueState
}

func (v OverlaysValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 20)

	var val tftypes.Value
	var err error

	attrTypes["endpoint_attr_queries"] = basetypes.ListType{
		ElemType: EndpointAttrQueriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["endpoint_state"] = basetypes.ListType{
		ElemType: EndpointStateValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["endpoint_state_heading"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["endpoint_state_heading_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link_attr_queries"] = basetypes.ListType{
		ElemType: LinkAttrQueriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["link_state"] = basetypes.ListType{
		ElemType: LinkStateValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["link_state_heading"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["link_state_heading_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_attr_queries"] = basetypes.ListType{
		ElemType: NodeAttrQueriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_badge"] = basetypes.ListType{
		ElemType: NodeBadgeValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_state"] = basetypes.ListType{
		ElemType: NodeStateValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_state_heading"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_state_heading_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 20)

		val, err = v.EndpointAttrQueries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_attr_queries"] = val

		val, err = v.EndpointState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_state"] = val

		val, err = v.EndpointStateHeading.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_state_heading"] = val

		val, err = v.EndpointStateHeadingKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_state_heading_key"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.LinkAttrQueries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_attr_queries"] = val

		val, err = v.LinkState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_state"] = val

		val, err = v.LinkStateHeading.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_state_heading"] = val

		val, err = v.LinkStateHeadingKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_state_heading_key"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeAttrQueries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_attr_queries"] = val

		val, err = v.NodeBadge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_badge"] = val

		val, err = v.NodeState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_state"] = val

		val, err = v.NodeStateHeading.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_state_heading"] = val

		val, err = v.NodeStateHeadingKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_state_heading_key"] = val

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverlaysValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverlaysValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverlaysValue) String() string {
	return "OverlaysValue"
}

func (v OverlaysValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	endpointAttrQueries := types.ListValueMust(
		EndpointAttrQueriesType{
			basetypes.ObjectType{
				AttrTypes: EndpointAttrQueriesValue{}.AttributeTypes(ctx),
			},
		},
		v.EndpointAttrQueries.Elements(),
	)

	if v.EndpointAttrQueries.IsNull() {
		endpointAttrQueries = types.ListNull(
			EndpointAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: EndpointAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.EndpointAttrQueries.IsUnknown() {
		endpointAttrQueries = types.ListUnknown(
			EndpointAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: EndpointAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	endpointState := types.ListValueMust(
		EndpointStateType{
			basetypes.ObjectType{
				AttrTypes: EndpointStateValue{}.AttributeTypes(ctx),
			},
		},
		v.EndpointState.Elements(),
	)

	if v.EndpointState.IsNull() {
		endpointState = types.ListNull(
			EndpointStateType{
				basetypes.ObjectType{
					AttrTypes: EndpointStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.EndpointState.IsUnknown() {
		endpointState = types.ListUnknown(
			EndpointStateType{
				basetypes.ObjectType{
					AttrTypes: EndpointStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	linkAttrQueries := types.ListValueMust(
		LinkAttrQueriesType{
			basetypes.ObjectType{
				AttrTypes: LinkAttrQueriesValue{}.AttributeTypes(ctx),
			},
		},
		v.LinkAttrQueries.Elements(),
	)

	if v.LinkAttrQueries.IsNull() {
		linkAttrQueries = types.ListNull(
			LinkAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: LinkAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LinkAttrQueries.IsUnknown() {
		linkAttrQueries = types.ListUnknown(
			LinkAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: LinkAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	linkState := types.ListValueMust(
		LinkStateType{
			basetypes.ObjectType{
				AttrTypes: LinkStateValue{}.AttributeTypes(ctx),
			},
		},
		v.LinkState.Elements(),
	)

	if v.LinkState.IsNull() {
		linkState = types.ListNull(
			LinkStateType{
				basetypes.ObjectType{
					AttrTypes: LinkStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LinkState.IsUnknown() {
		linkState = types.ListUnknown(
			LinkStateType{
				basetypes.ObjectType{
					AttrTypes: LinkStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeAttrQueries := types.ListValueMust(
		NodeAttrQueriesType{
			basetypes.ObjectType{
				AttrTypes: NodeAttrQueriesValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeAttrQueries.Elements(),
	)

	if v.NodeAttrQueries.IsNull() {
		nodeAttrQueries = types.ListNull(
			NodeAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: NodeAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeAttrQueries.IsUnknown() {
		nodeAttrQueries = types.ListUnknown(
			NodeAttrQueriesType{
				basetypes.ObjectType{
					AttrTypes: NodeAttrQueriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeBadge := types.ListValueMust(
		NodeBadgeType{
			basetypes.ObjectType{
				AttrTypes: NodeBadgeValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeBadge.Elements(),
	)

	if v.NodeBadge.IsNull() {
		nodeBadge = types.ListNull(
			NodeBadgeType{
				basetypes.ObjectType{
					AttrTypes: NodeBadgeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeBadge.IsUnknown() {
		nodeBadge = types.ListUnknown(
			NodeBadgeType{
				basetypes.ObjectType{
					AttrTypes: NodeBadgeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeState := types.ListValueMust(
		NodeStateType{
			basetypes.ObjectType{
				AttrTypes: NodeStateValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeState.Elements(),
	)

	if v.NodeState.IsNull() {
		nodeState = types.ListNull(
			NodeStateType{
				basetypes.ObjectType{
					AttrTypes: NodeStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeState.IsUnknown() {
		nodeState = types.ListUnknown(
			NodeStateType{
				basetypes.ObjectType{
					AttrTypes: NodeStateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"endpoint_attr_queries": basetypes.ListType{
			ElemType: EndpointAttrQueriesValue{}.Type(ctx),
		},
		"endpoint_state": basetypes.ListType{
			ElemType: EndpointStateValue{}.Type(ctx),
		},
		"endpoint_state_heading":     basetypes.StringType{},
		"endpoint_state_heading_key": basetypes.StringType{},
		"group":                      basetypes.StringType{},
		"link_attr_queries": basetypes.ListType{
			ElemType: LinkAttrQueriesValue{}.Type(ctx),
		},
		"link_state": basetypes.ListType{
			ElemType: LinkStateValue{}.Type(ctx),
		},
		"link_state_heading":     basetypes.StringType{},
		"link_state_heading_key": basetypes.StringType{},
		"name":                   basetypes.StringType{},
		"node_attr_queries": basetypes.ListType{
			ElemType: NodeAttrQueriesValue{}.Type(ctx),
		},
		"node_badge": basetypes.ListType{
			ElemType: NodeBadgeValue{}.Type(ctx),
		},
		"node_state": basetypes.ListType{
			ElemType: NodeStateValue{}.Type(ctx),
		},
		"node_state_heading":     basetypes.StringType{},
		"node_state_heading_key": basetypes.StringType{},
		"ui_description":         basetypes.StringType{},
		"ui_description_key":     basetypes.StringType{},
		"ui_name":                basetypes.StringType{},
		"ui_name_key":            basetypes.StringType{},
		"version":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"endpoint_attr_queries":      endpointAttrQueries,
			"endpoint_state":             endpointState,
			"endpoint_state_heading":     v.EndpointStateHeading,
			"endpoint_state_heading_key": v.EndpointStateHeadingKey,
			"group":                      v.Group,
			"link_attr_queries":          linkAttrQueries,
			"link_state":                 linkState,
			"link_state_heading":         v.LinkStateHeading,
			"link_state_heading_key":     v.LinkStateHeadingKey,
			"name":                       v.Name,
			"node_attr_queries":          nodeAttrQueries,
			"node_badge":                 nodeBadge,
			"node_state":                 nodeState,
			"node_state_heading":         v.NodeStateHeading,
			"node_state_heading_key":     v.NodeStateHeadingKey,
			"ui_description":             v.UiDescription,
			"ui_description_key":         v.UiDescriptionKey,
			"ui_name":                    v.UiName,
			"ui_name_key":                v.UiNameKey,
			"version":                    v.Version,
		})

	return objVal, diags
}

func (v OverlaysValue) Equal(o attr.Value) bool {
	other, ok := o.(OverlaysValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EndpointAttrQueries.Equal(other.EndpointAttrQueries) {
		return false
	}

	if !v.EndpointState.Equal(other.EndpointState) {
		return false
	}

	if !v.EndpointStateHeading.Equal(other.EndpointStateHeading) {
		return false
	}

	if !v.EndpointStateHeadingKey.Equal(other.EndpointStateHeadingKey) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.LinkAttrQueries.Equal(other.LinkAttrQueries) {
		return false
	}

	if !v.LinkState.Equal(other.LinkState) {
		return false
	}

	if !v.LinkStateHeading.Equal(other.LinkStateHeading) {
		return false
	}

	if !v.LinkStateHeadingKey.Equal(other.LinkStateHeadingKey) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeAttrQueries.Equal(other.NodeAttrQueries) {
		return false
	}

	if !v.NodeBadge.Equal(other.NodeBadge) {
		return false
	}

	if !v.NodeState.Equal(other.NodeState) {
		return false
	}

	if !v.NodeStateHeading.Equal(other.NodeStateHeading) {
		return false
	}

	if !v.NodeStateHeadingKey.Equal(other.NodeStateHeadingKey) {
		return false
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v OverlaysValue) Type(ctx context.Context) attr.Type {
	return OverlaysType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverlaysValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"endpoint_attr_queries": basetypes.ListType{
			ElemType: EndpointAttrQueriesValue{}.Type(ctx),
		},
		"endpoint_state": basetypes.ListType{
			ElemType: EndpointStateValue{}.Type(ctx),
		},
		"endpoint_state_heading":     basetypes.StringType{},
		"endpoint_state_heading_key": basetypes.StringType{},
		"group":                      basetypes.StringType{},
		"link_attr_queries": basetypes.ListType{
			ElemType: LinkAttrQueriesValue{}.Type(ctx),
		},
		"link_state": basetypes.ListType{
			ElemType: LinkStateValue{}.Type(ctx),
		},
		"link_state_heading":     basetypes.StringType{},
		"link_state_heading_key": basetypes.StringType{},
		"name":                   basetypes.StringType{},
		"node_attr_queries": basetypes.ListType{
			ElemType: NodeAttrQueriesValue{}.Type(ctx),
		},
		"node_badge": basetypes.ListType{
			ElemType: NodeBadgeValue{}.Type(ctx),
		},
		"node_state": basetypes.ListType{
			ElemType: NodeStateValue{}.Type(ctx),
		},
		"node_state_heading":     basetypes.StringType{},
		"node_state_heading_key": basetypes.StringType{},
		"ui_description":         basetypes.StringType{},
		"ui_description_key":     basetypes.StringType{},
		"ui_name":                basetypes.StringType{},
		"ui_name_key":            basetypes.StringType{},
		"version":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointAttrQueriesType{}

type EndpointAttrQueriesType struct {
	basetypes.ObjectType
}

func (t EndpointAttrQueriesType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointAttrQueriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointAttrQueriesType) String() string {
	return "EndpointAttrQueriesType"
}

func (t EndpointAttrQueriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.MapValue, was: %T`, attributesAttribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return nil, diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointAttrQueriesValue{
		Attributes: attributesVal,
		Query:      queryVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewEndpointAttrQueriesValueNull() EndpointAttrQueriesValue {
	return EndpointAttrQueriesValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointAttrQueriesValueUnknown() EndpointAttrQueriesValue {
	return EndpointAttrQueriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointAttrQueriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointAttrQueriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointAttrQueriesValue Attribute Value",
				"While creating a EndpointAttrQueriesValue value, a missing attribute value was detected. "+
					"A EndpointAttrQueriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointAttrQueriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointAttrQueriesValue Attribute Type",
				"While creating a EndpointAttrQueriesValue value, an invalid attribute value was detected. "+
					"A EndpointAttrQueriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointAttrQueriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointAttrQueriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointAttrQueriesValue Attribute Value",
				"While creating a EndpointAttrQueriesValue value, an extra attribute value was detected. "+
					"A EndpointAttrQueriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointAttrQueriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointAttrQueriesValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewEndpointAttrQueriesValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.MapValue, was: %T`, attributesAttribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return NewEndpointAttrQueriesValueUnknown(), diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return NewEndpointAttrQueriesValueUnknown(), diags
	}

	return EndpointAttrQueriesValue{
		Attributes: attributesVal,
		Query:      queryVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewEndpointAttrQueriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointAttrQueriesValue {
	object, diags := NewEndpointAttrQueriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointAttrQueriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointAttrQueriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointAttrQueriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointAttrQueriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointAttrQueriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointAttrQueriesValueMust(EndpointAttrQueriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointAttrQueriesType) ValueType(ctx context.Context) attr.Value {
	return EndpointAttrQueriesValue{}
}

var _ basetypes.ObjectValuable = EndpointAttrQueriesValue{}

type EndpointAttrQueriesValue struct {
	Attributes basetypes.MapValue    `tfsdk:"attributes"`
	Query      basetypes.StringValue `tfsdk:"query"`
	state      attr.ValueState
}

func (v EndpointAttrQueriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.MapType{
		ElemType: AttributesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["query"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Query.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointAttrQueriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointAttrQueriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointAttrQueriesValue) String() string {
	return "EndpointAttrQueriesValue"
}

func (v EndpointAttrQueriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := types.MapValueMust(
		AttributesType{
			basetypes.ObjectType{
				AttrTypes: AttributesValue{}.AttributeTypes(ctx),
			},
		},
		v.Attributes.Elements(),
	)

	if v.Attributes.IsNull() {
		attributes = types.MapNull(
			AttributesType{
				basetypes.ObjectType{
					AttrTypes: AttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.MapUnknown(
			AttributesType{
				basetypes.ObjectType{
					AttrTypes: AttributesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.MapType{
			ElemType: AttributesValue{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes": attributes,
			"query":      v.Query,
		})

	return objVal, diags
}

func (v EndpointAttrQueriesValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointAttrQueriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Query.Equal(other.Query) {
		return false
	}

	return true
}

func (v EndpointAttrQueriesValue) Type(ctx context.Context) attr.Type {
	return EndpointAttrQueriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointAttrQueriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.MapType{
			ElemType: AttributesValue{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	state            attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointStateType{}

type EndpointStateType struct {
	basetypes.ObjectType
}

func (t EndpointStateType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointStateType) String() string {
	return "EndpointStateType"
}

func (t EndpointStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return nil, diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewEndpointStateValueNull() EndpointStateValue {
	return EndpointStateValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointStateValueUnknown() EndpointStateValue {
	return EndpointStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointStateValue Attribute Value",
				"While creating a EndpointStateValue value, a missing attribute value was detected. "+
					"A EndpointStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointStateValue Attribute Type",
				"While creating a EndpointStateValue value, an invalid attribute value was detected. "+
					"A EndpointStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointStateValue Attribute Value",
				"While creating a EndpointStateValue value, an extra attribute value was detected. "+
					"A EndpointStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointStateValueUnknown(), diags
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewEndpointStateValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewEndpointStateValueUnknown(), diags
	}

	return EndpointStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewEndpointStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointStateValue {
	object, diags := NewEndpointStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointStateValueMust(EndpointStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointStateType) ValueType(ctx context.Context) attr.Value {
	return EndpointStateValue{}
}

var _ basetypes.ObjectValuable = EndpointStateValue{}

type EndpointStateValue struct {
	Color            basetypes.StringValue `tfsdk:"color"`
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	Value            basetypes.Int64Value  `tfsdk:"value"`
	state            attr.ValueState
}

func (v EndpointStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["color"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Color.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["color"] = val

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointStateValue) String() string {
	return "EndpointStateValue"
}

func (v EndpointStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"color":              v.Color,
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v EndpointStateValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Color.Equal(other.Color) {
		return false
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v EndpointStateValue) Type(ctx context.Context) attr.Type {
	return EndpointStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LinkAttrQueriesType{}

type LinkAttrQueriesType struct {
	basetypes.ObjectType
}

func (t LinkAttrQueriesType) Equal(o attr.Type) bool {
	other, ok := o.(LinkAttrQueriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinkAttrQueriesType) String() string {
	return "LinkAttrQueriesType"
}

func (t LinkAttrQueriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributes1Attribute, ok := attributes["attributes_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes_1 is missing from object`)

		return nil, diags
	}

	attributes1Val, ok := attributes1Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes_1 expected to be basetypes.MapValue, was: %T`, attributes1Attribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return nil, diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinkAttrQueriesValue{
		Attributes1: attributes1Val,
		Query:       queryVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLinkAttrQueriesValueNull() LinkAttrQueriesValue {
	return LinkAttrQueriesValue{
		state: attr.ValueStateNull,
	}
}

func NewLinkAttrQueriesValueUnknown() LinkAttrQueriesValue {
	return LinkAttrQueriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinkAttrQueriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinkAttrQueriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinkAttrQueriesValue Attribute Value",
				"While creating a LinkAttrQueriesValue value, a missing attribute value was detected. "+
					"A LinkAttrQueriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkAttrQueriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinkAttrQueriesValue Attribute Type",
				"While creating a LinkAttrQueriesValue value, an invalid attribute value was detected. "+
					"A LinkAttrQueriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkAttrQueriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinkAttrQueriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinkAttrQueriesValue Attribute Value",
				"While creating a LinkAttrQueriesValue value, an extra attribute value was detected. "+
					"A LinkAttrQueriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinkAttrQueriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinkAttrQueriesValueUnknown(), diags
	}

	attributes1Attribute, ok := attributes["attributes_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes_1 is missing from object`)

		return NewLinkAttrQueriesValueUnknown(), diags
	}

	attributes1Val, ok := attributes1Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes_1 expected to be basetypes.MapValue, was: %T`, attributes1Attribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return NewLinkAttrQueriesValueUnknown(), diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return NewLinkAttrQueriesValueUnknown(), diags
	}

	return LinkAttrQueriesValue{
		Attributes1: attributes1Val,
		Query:       queryVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLinkAttrQueriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinkAttrQueriesValue {
	object, diags := NewLinkAttrQueriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinkAttrQueriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinkAttrQueriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinkAttrQueriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinkAttrQueriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinkAttrQueriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinkAttrQueriesValueMust(LinkAttrQueriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinkAttrQueriesType) ValueType(ctx context.Context) attr.Value {
	return LinkAttrQueriesValue{}
}

var _ basetypes.ObjectValuable = LinkAttrQueriesValue{}

type LinkAttrQueriesValue struct {
	Attributes1 basetypes.MapValue    `tfsdk:"attributes_1"`
	Query       basetypes.StringValue `tfsdk:"query"`
	state       attr.ValueState
}

func (v LinkAttrQueriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["attributes_1"] = basetypes.MapType{
		ElemType: Attributes1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["query"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Attributes1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes_1"] = val

		val, err = v.Query.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinkAttrQueriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinkAttrQueriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinkAttrQueriesValue) String() string {
	return "LinkAttrQueriesValue"
}

func (v LinkAttrQueriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes1 := types.MapValueMust(
		Attributes1Type{
			basetypes.ObjectType{
				AttrTypes: Attributes1Value{}.AttributeTypes(ctx),
			},
		},
		v.Attributes1.Elements(),
	)

	if v.Attributes1.IsNull() {
		attributes1 = types.MapNull(
			Attributes1Type{
				basetypes.ObjectType{
					AttrTypes: Attributes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Attributes1.IsUnknown() {
		attributes1 = types.MapUnknown(
			Attributes1Type{
				basetypes.ObjectType{
					AttrTypes: Attributes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes_1": basetypes.MapType{
			ElemType: Attributes1Value{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes_1": attributes1,
			"query":        v.Query,
		})

	return objVal, diags
}

func (v LinkAttrQueriesValue) Equal(o attr.Value) bool {
	other, ok := o.(LinkAttrQueriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes1.Equal(other.Attributes1) {
		return false
	}

	if !v.Query.Equal(other.Query) {
		return false
	}

	return true
}

func (v LinkAttrQueriesValue) Type(ctx context.Context) attr.Type {
	return LinkAttrQueriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinkAttrQueriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes_1": basetypes.MapType{
			ElemType: Attributes1Value{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Attributes1Type{}

type Attributes1Type struct {
	basetypes.ObjectType
}

func (t Attributes1Type) Equal(o attr.Type) bool {
	other, ok := o.(Attributes1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Attributes1Type) String() string {
	return "Attributes1Type"
}

func (t Attributes1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Attributes1Value{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributes1ValueNull() Attributes1Value {
	return Attributes1Value{
		state: attr.ValueStateNull,
	}
}

func NewAttributes1ValueUnknown() Attributes1Value {
	return Attributes1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributes1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Attributes1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Attributes1Value Attribute Value",
				"While creating a Attributes1Value value, a missing attribute value was detected. "+
					"A Attributes1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Attributes1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Attributes1Value Attribute Type",
				"While creating a Attributes1Value value, an invalid attribute value was detected. "+
					"A Attributes1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Attributes1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Attributes1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Attributes1Value Attribute Value",
				"While creating a Attributes1Value value, an extra attribute value was detected. "+
					"A Attributes1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Attributes1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributes1ValueUnknown(), diags
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewAttributes1ValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewAttributes1ValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewAttributes1ValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewAttributes1ValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return NewAttributes1ValueUnknown(), diags
	}

	return Attributes1Value{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributes1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Attributes1Value {
	object, diags := NewAttributes1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributes1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Attributes1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributes1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributes1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributes1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributes1ValueMust(Attributes1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Attributes1Type) ValueType(ctx context.Context) attr.Value {
	return Attributes1Value{}
}

var _ basetypes.ObjectValuable = Attributes1Value{}

type Attributes1Value struct {
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	state            attr.ValueState
}

func (v Attributes1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Attributes1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Attributes1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Attributes1Value) String() string {
	return "Attributes1Value"
}

func (v Attributes1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
		})

	return objVal, diags
}

func (v Attributes1Value) Equal(o attr.Value) bool {
	other, ok := o.(Attributes1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	return true
}

func (v Attributes1Value) Type(ctx context.Context) attr.Type {
	return Attributes1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Attributes1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinkStateType{}

type LinkStateType struct {
	basetypes.ObjectType
}

func (t LinkStateType) Equal(o attr.Type) bool {
	other, ok := o.(LinkStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinkStateType) String() string {
	return "LinkStateType"
}

func (t LinkStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return nil, diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinkStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLinkStateValueNull() LinkStateValue {
	return LinkStateValue{
		state: attr.ValueStateNull,
	}
}

func NewLinkStateValueUnknown() LinkStateValue {
	return LinkStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinkStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinkStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinkStateValue Attribute Value",
				"While creating a LinkStateValue value, a missing attribute value was detected. "+
					"A LinkStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinkStateValue Attribute Type",
				"While creating a LinkStateValue value, an invalid attribute value was detected. "+
					"A LinkStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinkStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinkStateValue Attribute Value",
				"While creating a LinkStateValue value, an extra attribute value was detected. "+
					"A LinkStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinkStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinkStateValueUnknown(), diags
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewLinkStateValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewLinkStateValueUnknown(), diags
	}

	return LinkStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLinkStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinkStateValue {
	object, diags := NewLinkStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinkStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinkStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinkStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinkStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinkStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinkStateValueMust(LinkStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinkStateType) ValueType(ctx context.Context) attr.Value {
	return LinkStateValue{}
}

var _ basetypes.ObjectValuable = LinkStateValue{}

type LinkStateValue struct {
	Color            basetypes.StringValue `tfsdk:"color"`
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	Value            basetypes.Int64Value  `tfsdk:"value"`
	state            attr.ValueState
}

func (v LinkStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["color"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Color.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["color"] = val

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinkStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinkStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinkStateValue) String() string {
	return "LinkStateValue"
}

func (v LinkStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"color":              v.Color,
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v LinkStateValue) Equal(o attr.Value) bool {
	other, ok := o.(LinkStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Color.Equal(other.Color) {
		return false
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v LinkStateValue) Type(ctx context.Context) attr.Type {
	return LinkStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinkStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = NodeAttrQueriesType{}

type NodeAttrQueriesType struct {
	basetypes.ObjectType
}

func (t NodeAttrQueriesType) Equal(o attr.Type) bool {
	other, ok := o.(NodeAttrQueriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeAttrQueriesType) String() string {
	return "NodeAttrQueriesType"
}

func (t NodeAttrQueriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributes2Attribute, ok := attributes["attributes_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes_2 is missing from object`)

		return nil, diags
	}

	attributes2Val, ok := attributes2Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes_2 expected to be basetypes.MapValue, was: %T`, attributes2Attribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return nil, diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeAttrQueriesValue{
		Attributes2: attributes2Val,
		Query:       queryVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNodeAttrQueriesValueNull() NodeAttrQueriesValue {
	return NodeAttrQueriesValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeAttrQueriesValueUnknown() NodeAttrQueriesValue {
	return NodeAttrQueriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeAttrQueriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeAttrQueriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeAttrQueriesValue Attribute Value",
				"While creating a NodeAttrQueriesValue value, a missing attribute value was detected. "+
					"A NodeAttrQueriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeAttrQueriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeAttrQueriesValue Attribute Type",
				"While creating a NodeAttrQueriesValue value, an invalid attribute value was detected. "+
					"A NodeAttrQueriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeAttrQueriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeAttrQueriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeAttrQueriesValue Attribute Value",
				"While creating a NodeAttrQueriesValue value, an extra attribute value was detected. "+
					"A NodeAttrQueriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeAttrQueriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeAttrQueriesValueUnknown(), diags
	}

	attributes2Attribute, ok := attributes["attributes_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes_2 is missing from object`)

		return NewNodeAttrQueriesValueUnknown(), diags
	}

	attributes2Val, ok := attributes2Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes_2 expected to be basetypes.MapValue, was: %T`, attributes2Attribute))
	}

	queryAttribute, ok := attributes["query"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query is missing from object`)

		return NewNodeAttrQueriesValueUnknown(), diags
	}

	queryVal, ok := queryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query expected to be basetypes.StringValue, was: %T`, queryAttribute))
	}

	if diags.HasError() {
		return NewNodeAttrQueriesValueUnknown(), diags
	}

	return NodeAttrQueriesValue{
		Attributes2: attributes2Val,
		Query:       queryVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewNodeAttrQueriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeAttrQueriesValue {
	object, diags := NewNodeAttrQueriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeAttrQueriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeAttrQueriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeAttrQueriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeAttrQueriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeAttrQueriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeAttrQueriesValueMust(NodeAttrQueriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeAttrQueriesType) ValueType(ctx context.Context) attr.Value {
	return NodeAttrQueriesValue{}
}

var _ basetypes.ObjectValuable = NodeAttrQueriesValue{}

type NodeAttrQueriesValue struct {
	Attributes2 basetypes.MapValue    `tfsdk:"attributes_2"`
	Query       basetypes.StringValue `tfsdk:"query"`
	state       attr.ValueState
}

func (v NodeAttrQueriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["attributes_2"] = basetypes.MapType{
		ElemType: Attributes2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["query"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Attributes2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes_2"] = val

		val, err = v.Query.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeAttrQueriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeAttrQueriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeAttrQueriesValue) String() string {
	return "NodeAttrQueriesValue"
}

func (v NodeAttrQueriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes2 := types.MapValueMust(
		Attributes2Type{
			basetypes.ObjectType{
				AttrTypes: Attributes2Value{}.AttributeTypes(ctx),
			},
		},
		v.Attributes2.Elements(),
	)

	if v.Attributes2.IsNull() {
		attributes2 = types.MapNull(
			Attributes2Type{
				basetypes.ObjectType{
					AttrTypes: Attributes2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Attributes2.IsUnknown() {
		attributes2 = types.MapUnknown(
			Attributes2Type{
				basetypes.ObjectType{
					AttrTypes: Attributes2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes_2": basetypes.MapType{
			ElemType: Attributes2Value{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes_2": attributes2,
			"query":        v.Query,
		})

	return objVal, diags
}

func (v NodeAttrQueriesValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeAttrQueriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes2.Equal(other.Attributes2) {
		return false
	}

	if !v.Query.Equal(other.Query) {
		return false
	}

	return true
}

func (v NodeAttrQueriesValue) Type(ctx context.Context) attr.Type {
	return NodeAttrQueriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeAttrQueriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes_2": basetypes.MapType{
			ElemType: Attributes2Value{}.Type(ctx),
		},
		"query": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Attributes2Type{}

type Attributes2Type struct {
	basetypes.ObjectType
}

func (t Attributes2Type) Equal(o attr.Type) bool {
	other, ok := o.(Attributes2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Attributes2Type) String() string {
	return "Attributes2Type"
}

func (t Attributes2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Attributes2Value{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributes2ValueNull() Attributes2Value {
	return Attributes2Value{
		state: attr.ValueStateNull,
	}
}

func NewAttributes2ValueUnknown() Attributes2Value {
	return Attributes2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributes2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Attributes2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Attributes2Value Attribute Value",
				"While creating a Attributes2Value value, a missing attribute value was detected. "+
					"A Attributes2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Attributes2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Attributes2Value Attribute Type",
				"While creating a Attributes2Value value, an invalid attribute value was detected. "+
					"A Attributes2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Attributes2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Attributes2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Attributes2Value Attribute Value",
				"While creating a Attributes2Value value, an extra attribute value was detected. "+
					"A Attributes2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Attributes2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributes2ValueUnknown(), diags
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewAttributes2ValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewAttributes2ValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewAttributes2ValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewAttributes2ValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	if diags.HasError() {
		return NewAttributes2ValueUnknown(), diags
	}

	return Attributes2Value{
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributes2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Attributes2Value {
	object, diags := NewAttributes2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributes2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Attributes2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributes2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributes2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributes2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributes2ValueMust(Attributes2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Attributes2Type) ValueType(ctx context.Context) attr.Value {
	return Attributes2Value{}
}

var _ basetypes.ObjectValuable = Attributes2Value{}

type Attributes2Value struct {
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	state            attr.ValueState
}

func (v Attributes2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Attributes2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Attributes2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Attributes2Value) String() string {
	return "Attributes2Value"
}

func (v Attributes2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
		})

	return objVal, diags
}

func (v Attributes2Value) Equal(o attr.Value) bool {
	other, ok := o.(Attributes2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	return true
}

func (v Attributes2Value) Type(ctx context.Context) attr.Type {
	return Attributes2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Attributes2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeBadgeType{}

type NodeBadgeType struct {
	basetypes.ObjectType
}

func (t NodeBadgeType) Equal(o attr.Type) bool {
	other, ok := o.(NodeBadgeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeBadgeType) String() string {
	return "NodeBadgeType"
}

func (t NodeBadgeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	badgeNameAttribute, ok := attributes["badge_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`badge_name is missing from object`)

		return nil, diags
	}

	badgeNameVal, ok := badgeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`badge_name expected to be basetypes.StringValue, was: %T`, badgeNameAttribute))
	}

	badgePathAttribute, ok := attributes["badge_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`badge_path is missing from object`)

		return nil, diags
	}

	badgePathVal, ok := badgePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`badge_path expected to be basetypes.StringValue, was: %T`, badgePathAttribute))
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return nil, diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeBadgeValue{
		BadgeName:        badgeNameVal,
		BadgePath:        badgePathVal,
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodeBadgeValueNull() NodeBadgeValue {
	return NodeBadgeValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeBadgeValueUnknown() NodeBadgeValue {
	return NodeBadgeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeBadgeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeBadgeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeBadgeValue Attribute Value",
				"While creating a NodeBadgeValue value, a missing attribute value was detected. "+
					"A NodeBadgeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeBadgeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeBadgeValue Attribute Type",
				"While creating a NodeBadgeValue value, an invalid attribute value was detected. "+
					"A NodeBadgeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeBadgeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeBadgeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeBadgeValue Attribute Value",
				"While creating a NodeBadgeValue value, an extra attribute value was detected. "+
					"A NodeBadgeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeBadgeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeBadgeValueUnknown(), diags
	}

	badgeNameAttribute, ok := attributes["badge_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`badge_name is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	badgeNameVal, ok := badgeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`badge_name expected to be basetypes.StringValue, was: %T`, badgeNameAttribute))
	}

	badgePathAttribute, ok := attributes["badge_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`badge_path is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	badgePathVal, ok := badgePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`badge_path expected to be basetypes.StringValue, was: %T`, badgePathAttribute))
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewNodeBadgeValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewNodeBadgeValueUnknown(), diags
	}

	return NodeBadgeValue{
		BadgeName:        badgeNameVal,
		BadgePath:        badgePathVal,
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodeBadgeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeBadgeValue {
	object, diags := NewNodeBadgeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeBadgeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeBadgeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeBadgeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeBadgeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeBadgeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeBadgeValueMust(NodeBadgeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeBadgeType) ValueType(ctx context.Context) attr.Value {
	return NodeBadgeValue{}
}

var _ basetypes.ObjectValuable = NodeBadgeValue{}

type NodeBadgeValue struct {
	BadgeName        basetypes.StringValue `tfsdk:"badge_name"`
	BadgePath        basetypes.StringValue `tfsdk:"badge_path"`
	Color            basetypes.StringValue `tfsdk:"color"`
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	Value            basetypes.Int64Value  `tfsdk:"value"`
	state            attr.ValueState
}

func (v NodeBadgeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["badge_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["badge_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["color"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BadgeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["badge_name"] = val

		val, err = v.BadgePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["badge_path"] = val

		val, err = v.Color.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["color"] = val

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeBadgeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeBadgeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeBadgeValue) String() string {
	return "NodeBadgeValue"
}

func (v NodeBadgeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"badge_name":         basetypes.StringType{},
		"badge_path":         basetypes.StringType{},
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"badge_name":         v.BadgeName,
			"badge_path":         v.BadgePath,
			"color":              v.Color,
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v NodeBadgeValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeBadgeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BadgeName.Equal(other.BadgeName) {
		return false
	}

	if !v.BadgePath.Equal(other.BadgePath) {
		return false
	}

	if !v.Color.Equal(other.Color) {
		return false
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v NodeBadgeValue) Type(ctx context.Context) attr.Type {
	return NodeBadgeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeBadgeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"badge_name":         basetypes.StringType{},
		"badge_path":         basetypes.StringType{},
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = NodeStateType{}

type NodeStateType struct {
	basetypes.ObjectType
}

func (t NodeStateType) Equal(o attr.Type) bool {
	other, ok := o.(NodeStateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeStateType) String() string {
	return "NodeStateType"
}

func (t NodeStateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return nil, diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return nil, diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return nil, diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return nil, diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return nil, diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodeStateValueNull() NodeStateValue {
	return NodeStateValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeStateValueUnknown() NodeStateValue {
	return NodeStateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeStateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeStateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeStateValue Attribute Value",
				"While creating a NodeStateValue value, a missing attribute value was detected. "+
					"A NodeStateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeStateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeStateValue Attribute Type",
				"While creating a NodeStateValue value, an invalid attribute value was detected. "+
					"A NodeStateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeStateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeStateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeStateValue Attribute Value",
				"While creating a NodeStateValue value, an extra attribute value was detected. "+
					"A NodeStateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeStateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeStateValueUnknown(), diags
	}

	colorAttribute, ok := attributes["color"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`color is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	colorVal, ok := colorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`color expected to be basetypes.StringValue, was: %T`, colorAttribute))
	}

	uiDescriptionAttribute, ok := attributes["ui_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	uiDescriptionVal, ok := uiDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description expected to be basetypes.StringValue, was: %T`, uiDescriptionAttribute))
	}

	uiDescriptionKeyAttribute, ok := attributes["ui_description_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_description_key is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	uiDescriptionKeyVal, ok := uiDescriptionKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_description_key expected to be basetypes.StringValue, was: %T`, uiDescriptionKeyAttribute))
	}

	uiNameAttribute, ok := attributes["ui_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	uiNameVal, ok := uiNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name expected to be basetypes.StringValue, was: %T`, uiNameAttribute))
	}

	uiNameKeyAttribute, ok := attributes["ui_name_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_name_key is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	uiNameKeyVal, ok := uiNameKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_name_key expected to be basetypes.StringValue, was: %T`, uiNameKeyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewNodeStateValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewNodeStateValueUnknown(), diags
	}

	return NodeStateValue{
		Color:            colorVal,
		UiDescription:    uiDescriptionVal,
		UiDescriptionKey: uiDescriptionKeyVal,
		UiName:           uiNameVal,
		UiNameKey:        uiNameKeyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodeStateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeStateValue {
	object, diags := NewNodeStateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeStateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeStateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeStateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeStateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeStateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeStateValueMust(NodeStateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeStateType) ValueType(ctx context.Context) attr.Value {
	return NodeStateValue{}
}

var _ basetypes.ObjectValuable = NodeStateValue{}

type NodeStateValue struct {
	Color            basetypes.StringValue `tfsdk:"color"`
	UiDescription    basetypes.StringValue `tfsdk:"ui_description"`
	UiDescriptionKey basetypes.StringValue `tfsdk:"ui_description_key"`
	UiName           basetypes.StringValue `tfsdk:"ui_name"`
	UiNameKey        basetypes.StringValue `tfsdk:"ui_name_key"`
	Value            basetypes.Int64Value  `tfsdk:"value"`
	state            attr.ValueState
}

func (v NodeStateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["color"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_description_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ui_name_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Color.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["color"] = val

		val, err = v.UiDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description"] = val

		val, err = v.UiDescriptionKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_description_key"] = val

		val, err = v.UiName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name"] = val

		val, err = v.UiNameKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_name_key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeStateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeStateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeStateValue) String() string {
	return "NodeStateValue"
}

func (v NodeStateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"color":              v.Color,
			"ui_description":     v.UiDescription,
			"ui_description_key": v.UiDescriptionKey,
			"ui_name":            v.UiName,
			"ui_name_key":        v.UiNameKey,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v NodeStateValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeStateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Color.Equal(other.Color) {
		return false
	}

	if !v.UiDescription.Equal(other.UiDescription) {
		return false
	}

	if !v.UiDescriptionKey.Equal(other.UiDescriptionKey) {
		return false
	}

	if !v.UiName.Equal(other.UiName) {
		return false
	}

	if !v.UiNameKey.Equal(other.UiNameKey) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v NodeStateValue) Type(ctx context.Context) attr.Type {
	return NodeStateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeStateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"color":              basetypes.StringType{},
		"ui_description":     basetypes.StringType{},
		"ui_description_key": basetypes.StringType{},
		"ui_name":            basetypes.StringType{},
		"ui_name_key":        basetypes.StringType{},
		"value":              basetypes.Int64Type{},
	}
}
